#!/bin/bash
# Security Exploit Test Suite
# 证明安全机制无法被绕过

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo "🔐 Security Exploit Test Suite"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

TESTS_PASSED=0
TESTS_FAILED=0

# ═══════════════════════════════════════════════════════════════════
# Test 1: 尝试绕过safe_rm_rf路径白名单
# ═══════════════════════════════════════════════════════════════════
echo -e "${BLUE}[TEST 1] Path Whitelist Bypass Attempt${NC}"

test_rm_bypass() {
    local test_script="/tmp/test_safe_rm.sh"
    
    # 提取safe_rm_rf函数
    cat > "$test_script" << 'INNER_EOF'
#!/bin/bash
source .claude/hooks/performance_optimized_hooks_SECURE.sh

# 尝试1: 删除根目录（应失败）
echo "Attempt 1: Deleting /"
if safe_rm_rf "/" 2>&1 | grep -q "SECURITY"; then
    echo "  ✓ Blocked as expected"
    exit 0
else
    echo "  ✗ SECURITY BREACH: Root deletion not blocked!"
    exit 1
fi
INNER_EOF
    
    chmod +x "$test_script"
    
    if bash "$test_script"; then
        echo -e "${GREEN}✅ Test 1.1: Root path blocked${NC}"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}❌ Test 1.1: FAILED${NC}"
        ((TESTS_FAILED++))
    fi
    rm -f "$test_script"
    
    # 尝试2: 删除home目录（应失败）
    cat > "$test_script" << 'INNER_EOF2'
#!/bin/bash
source .claude/hooks/performance_optimized_hooks_SECURE.sh

echo "Attempt 2: Deleting $HOME"
if safe_rm_rf "$HOME" 2>&1 | grep -q "SECURITY"; then
    echo "  ✓ Blocked as expected"
    exit 0
else
    echo "  ✗ SECURITY BREACH!"
    exit 1
fi
INNER_EOF2
    
    chmod +x "$test_script"
    
    if bash "$test_script"; then
        echo -e "${GREEN}✅ Test 1.2: Home directory blocked${NC}"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}❌ Test 1.2: FAILED${NC}"
        ((TESTS_FAILED++))
    fi
    rm -f "$test_script"
    
    # 尝试3: 路径注入攻击（应失败）
    cat > "$test_script" << 'INNER_EOF3'
#!/bin/bash
source .claude/hooks/performance_optimized_hooks_SECURE.sh

echo "Attempt 3: Path injection with /../"
if safe_rm_rf "/tmp/../home" 2>&1 | grep -q "SECURITY"; then
    echo "  ✓ Blocked as expected"
    exit 0
else
    echo "  ✗ SECURITY BREACH!"
    exit 1
fi
INNER_EOF3
    
    chmod +x "$test_script"
    
    if bash "$test_script"; then
        echo -e "${GREEN}✅ Test 1.3: Path injection blocked${NC}"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}❌ Test 1.3: FAILED${NC}"
        ((TESTS_FAILED++))
    fi
    rm -f "$test_script"
}

test_rm_bypass

echo ""

# ═══════════════════════════════════════════════════════════════════
# Test 2: 尝试伪造GPG签名
# ═══════════════════════════════════════════════════════════════════
echo -e "${BLUE}[TEST 2] GPG Signature Forgery Attempt${NC}"

test_gpg_forgery() {
    # 创建假的gate文件
    mkdir -p .gates
    echo "phase=P99" > .gates/99.ok
    echo "gate=99" >> .gates/99.ok
    echo "FORGED" >> .gates/99.ok
    
    # 尝试1: 无签名文件
    echo "Attempt 1: Gate without signature"
    if ./.workflow/scripts/sign_gate_GPG.sh P99 99 verify 2>&1 | grep -q "ERROR"; then
        echo -e "${GREEN}  ✓ Unsigned gate rejected${NC}"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}  ✗ FAILED: Unsigned gate accepted!${NC}"
        ((TESTS_FAILED++))
    fi
    
    # 尝试2: 伪造的SHA256签名（旧系统）
    cat > .gates/99.ok.sig << 'FAKE_SIG'
phase=P99
gate=99
sha256=abcdef1234567890
FAKE_SIG
    
    echo "Attempt 2: Fake SHA256 signature"
    if ./.workflow/scripts/sign_gate_GPG.sh P99 99 verify 2>&1 | grep -q "ERROR\|INVALID"; then
        echo -e "${GREEN}  ✓ Fake SHA256 signature rejected${NC}"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}  ✗ FAILED: Fake signature accepted!${NC}"
        ((TESTS_FAILED++))
    fi
    
    # 尝试3: 篡改已签名的gate
    # 首先创建合法签名
    ./.workflow/scripts/sign_gate_GPG.sh P7 07 create &>/dev/null || true
    
    if [[ -f .gates/07.ok.sig ]]; then
        # 篡改gate内容
        echo "TAMPERED" >> .gates/07.ok
        
        echo "Attempt 3: Tampering with signed gate"
        if ./.workflow/scripts/sign_gate_GPG.sh P7 07 verify 2>&1 | grep -q "INVALID\|BAD"; then
            echo -e "${GREEN}  ✓ Tampered gate detected${NC}"
            ((TESTS_PASSED++))
        else
            echo -e "${RED}  ✗ FAILED: Tampering not detected!${NC}"
            ((TESTS_FAILED++))
        fi
    else
        echo -e "${YELLOW}  ⚠️  Skipped (GPG key setup needed)${NC}"
    fi
    
    # 清理
    rm -f .gates/99.ok .gates/99.ok.sig
}

test_gpg_forgery

echo ""

# ═══════════════════════════════════════════════════════════════════
# Test 3: 符号链接攻击
# ═══════════════════════════════════════════════════════════════════
echo -e "${BLUE}[TEST 3] Symlink Attack Prevention${NC}"

test_symlink_attack() {
    local test_script="/tmp/test_symlink.sh"
    
    # 创建符号链接指向重要目录
    local symlink_path="/tmp/test_symlink_attack"
    ln -sf /etc "$symlink_path" 2>/dev/null || true
    
    cat > "$test_script" << 'INNER_SYMLINK'
#!/bin/bash
source .claude/hooks/performance_optimized_hooks_SECURE.sh

echo "Attempt: Delete via symlink to /etc"
if safe_rm_rf "/tmp/test_symlink_attack" 2>&1 | grep -q "SECURITY.*symbolic link"; then
    echo "  ✓ Symlink attack blocked"
    exit 0
else
    echo "  ✗ SECURITY BREACH!"
    exit 1
fi
INNER_SYMLINK
    
    chmod +x "$test_script"
    
    if bash "$test_script"; then
        echo -e "${GREEN}✅ Symlink attack prevented${NC}"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}❌ FAILED: Symlink attack succeeded!${NC}"
        ((TESTS_FAILED++))
    fi
    
    rm -f "$test_script"
    rm -f "$symlink_path"
}

test_symlink_attack

echo ""

# ═══════════════════════════════════════════════════════════════════
# Test 4: Dry-run验证
# ═══════════════════════════════════════════════════════════════════
echo -e "${BLUE}[TEST 4] Dry-run Mode${NC}"

test_dry_run() {
    local test_script="/tmp/test_dryrun.sh"
    local test_dir="/tmp/test_dryrun_dir_$$"
    mkdir -p "$test_dir"
    touch "$test_dir/file1.txt"
    
    cat > "$test_script" << INNER_DRYRUN
#!/bin/bash
source .claude/hooks/performance_optimized_hooks_SECURE.sh

export DRY_RUN=1

if safe_rm_rf "$test_dir" 2>&1 | grep -q "DRY-RUN"; then
    # 检查目录仍然存在
    if [[ -d "$test_dir" ]]; then
        echo "  ✓ Dry-run: Directory not deleted"
        exit 0
    else
        echo "  ✗ Directory was deleted in dry-run mode!"
        exit 1
    fi
else
    echo "  ✗ Dry-run flag not respected"
    exit 1
fi
INNER_DRYRUN
    
    chmod +x "$test_script"
    
    if bash "$test_script"; then
        echo -e "${GREEN}✅ Dry-run mode working${NC}"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}❌ FAILED: Dry-run not working${NC}"
        ((TESTS_FAILED++))
    fi
    
    rm -rf "$test_dir" "$test_script"
}

test_dry_run

echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo -e "${BLUE}Test Results:${NC}"
echo -e "${GREEN}Passed: $TESTS_PASSED${NC}"
echo -e "${RED}Failed: $TESTS_FAILED${NC}"
echo ""

if [[ $TESTS_FAILED -eq 0 ]]; then
    echo -e "${GREEN}✅ All security tests passed!${NC}"
    echo "Security mechanisms are working correctly."
    exit 0
else
    echo -e "${RED}❌ Security tests failed!${NC}"
    echo "CRITICAL: Security vulnerabilities detected!"
    exit 1
fi
