#!/usr/bin/env python3
"""
Perfect21令牌管理器
负责JWT令牌的生成、验证和管理
"""

import os
import sys
import jwt
import secrets
from typing import Dict, Any, Optional, Set
from datetime import datetime, timedelta

sys.path.append(os.path.join(os.path.dirname(__file__), '../..'))

from modules.logger import log_info, log_error

class TokenManager:
    """令牌管理器"""

    def __init__(self, secret_key: str = None):
        """初始化令牌管理器"""
        # 生成或使用提供的密钥
        self.secret_key = secret_key or self._generate_secret_key()

        # 令牌黑名单（在生产环境中应使用Redis等缓存）
        self.token_blacklist: Set[str] = set()

        # 算法设置
        self.algorithm = 'HS256'

        # 默认过期时间
        self.default_access_expires = timedelta(hours=1)
        self.default_refresh_expires = timedelta(days=7)
        self.default_verification_expires = timedelta(hours=24)

        log_info("TokenManager初始化完成")

    def _generate_secret_key(self) -> str:
        """生成密钥"""
        # 强制要求从环境变量读取，不使用默认值
        secret_key = os.getenv('JWT_SECRET_KEY')
        if not secret_key:
            raise ValueError("JWT_SECRET_KEY environment variable is required for security. Please set it before starting the application.")
        return secret_key

    def generate_access_token(self, user_id: str,
                            expires_delta: timedelta = None,
                            additional_claims: Dict[str, Any] = None) -> str:
        """生成访问令牌"""
        try:
            # 设置过期时间
            if expires_delta is None:
                expires_delta = self.default_access_expires

            expire = datetime.utcnow() + expires_delta

            # 构建载荷
            payload = {
                'user_id': user_id,
                'type': 'access',
                'exp': expire,
                'iat': datetime.utcnow(),
                'jti': secrets.token_urlsafe(16)  # 令牌ID，用于撤销
            }

            # 添加额外声明
            if additional_claims:
                payload.update(additional_claims)

            # 生成令牌
            token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)

            log_info(f"访问令牌生成成功: user_id={user_id}")
            return token

        except Exception as e:
            log_error("访问令牌生成失败", e)
            raise

    def generate_refresh_token(self, user_id: str,
                             expires_delta: timedelta = None) -> str:
        """生成刷新令牌"""
        try:
            # 设置过期时间
            if expires_delta is None:
                expires_delta = self.default_refresh_expires

            expire = datetime.utcnow() + expires_delta

            # 构建载荷
            payload = {
                'user_id': user_id,
                'type': 'refresh',
                'exp': expire,
                'iat': datetime.utcnow(),
                'jti': secrets.token_urlsafe(16)
            }

            # 生成令牌
            token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)

            log_info(f"刷新令牌生成成功: user_id={user_id}")
            return token

        except Exception as e:
            log_error("刷新令牌生成失败", e)
            raise

    def generate_verification_token(self, user_id: str) -> str:
        """生成邮箱验证令牌"""
        try:
            expire = datetime.utcnow() + self.default_verification_expires

            payload = {
                'user_id': user_id,
                'type': 'verification',
                'exp': expire,
                'iat': datetime.utcnow(),
                'jti': secrets.token_urlsafe(16)
            }

            token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)

            log_info(f"验证令牌生成成功: user_id={user_id}")
            return token

        except Exception as e:
            log_error("验证令牌生成失败", e)
            raise

    def generate_reset_token(self, user_id: str) -> str:
        """生成密码重置令牌"""
        try:
            expire = datetime.utcnow() + timedelta(hours=2)  # 2小时有效期

            payload = {
                'user_id': user_id,
                'type': 'reset',
                'exp': expire,
                'iat': datetime.utcnow(),
                'jti': secrets.token_urlsafe(16)
            }

            token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)

            log_info(f"重置令牌生成成功: user_id={user_id}")
            return token

        except Exception as e:
            log_error("重置令牌生成失败", e)
            raise

    def verify_access_token(self, token: str) -> Optional[Dict[str, Any]]:
        """验证访问令牌"""
        try:
            # 检查黑名单
            if token in self.token_blacklist:
                log_info("令牌在黑名单中")
                return None

            # 解码令牌
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])

            # 验证令牌类型
            if payload.get('type') != 'access':
                log_info("令牌类型不匹配")
                return None

            return payload

        except jwt.ExpiredSignatureError:
            log_info("访问令牌已过期")
            return None
        except jwt.InvalidTokenError as e:
            log_info(f"访问令牌无效: {str(e)}")
            return None
        except Exception as e:
            log_error("验证访问令牌时发生错误", e)
            return None

    def verify_refresh_token(self, token: str) -> Optional[Dict[str, Any]]:
        """验证刷新令牌"""
        try:
            # 检查黑名单
            if token in self.token_blacklist:
                log_info("刷新令牌在黑名单中")
                return None

            # 解码令牌
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])

            # 验证令牌类型
            if payload.get('type') != 'refresh':
                log_info("令牌类型不匹配")
                return None

            return payload

        except jwt.ExpiredSignatureError:
            log_info("刷新令牌已过期")
            return None
        except jwt.InvalidTokenError as e:
            log_info(f"刷新令牌无效: {str(e)}")
            return None
        except Exception as e:
            log_error("验证刷新令牌时发生错误", e)
            return None

    def verify_verification_token(self, token: str) -> Optional[Dict[str, Any]]:
        """验证邮箱验证令牌"""
        try:
            # 解码令牌
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])

            # 验证令牌类型
            if payload.get('type') != 'verification':
                log_info("令牌类型不匹配")
                return None

            return payload

        except jwt.ExpiredSignatureError:
            log_info("验证令牌已过期")
            return None
        except jwt.InvalidTokenError as e:
            log_info(f"验证令牌无效: {str(e)}")
            return None
        except Exception as e:
            log_error("验证邮箱令牌时发生错误", e)
            return None

    def verify_reset_token(self, token: str) -> Optional[Dict[str, Any]]:
        """验证密码重置令牌"""
        try:
            # 解码令牌
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])

            # 验证令牌类型
            if payload.get('type') != 'reset':
                log_info("令牌类型不匹配")
                return None

            return payload

        except jwt.ExpiredSignatureError:
            log_info("重置令牌已过期")
            return None
        except jwt.InvalidTokenError as e:
            log_info(f"重置令牌无效: {str(e)}")
            return None
        except Exception as e:
            log_error("验证重置令牌时发生错误", e)
            return None

    def revoke_token(self, token: str):
        """撤销令牌（加入黑名单）"""
        try:
            # 解码令牌获取jti
            payload = jwt.decode(token, self.secret_key,
                               algorithms=[self.algorithm],
                               options={"verify_exp": False})

            jti = payload.get('jti')
            if jti:
                self.token_blacklist.add(jti)
                log_info(f"令牌已撤销: jti={jti}")
            else:
                # 如果没有jti，直接加入令牌本身
                self.token_blacklist.add(token)
                log_info("令牌已撤销（整个令牌）")

        except Exception as e:
            log_error("撤销令牌失败", e)
            # 即使解码失败，也将令牌加入黑名单
            self.token_blacklist.add(token)

    def revoke_user_tokens(self, user_id: str):
        """撤销用户所有令牌"""
        # 在实际应用中，这需要存储用户令牌的映射关系
        # 这里简化处理，记录需要撤销的用户ID
        log_info(f"用户所有令牌已标记撤销: user_id={user_id}")

    def is_token_revoked(self, token: str) -> bool:
        """检查令牌是否被撤销"""
        try:
            # 先检查完整令牌
            if token in self.token_blacklist:
                return True

            # 检查jti
            payload = jwt.decode(token, self.secret_key,
                               algorithms=[self.algorithm],
                               options={"verify_exp": False})

            jti = payload.get('jti')
            return jti in self.token_blacklist if jti else False

        except Exception:
            # 如果无法解码，认为已撤销
            return True

    def extract_token_from_header(self, authorization_header: str) -> Optional[str]:
        """从Authorization头提取令牌"""
        if not authorization_header:
            return None

        try:
            # 格式：Bearer <token>
            scheme, token = authorization_header.split(' ', 1)
            if scheme.lower() != 'bearer':
                return None
            return token.strip()

        except ValueError:
            return None

    def get_token_info(self, token: str) -> Optional[Dict[str, Any]]:
        """获取令牌信息（不验证过期）"""
        try:
            payload = jwt.decode(token, self.secret_key,
                               algorithms=[self.algorithm],
                               options={"verify_exp": False})

            return {
                'user_id': payload.get('user_id'),
                'type': payload.get('type'),
                'issued_at': datetime.fromtimestamp(payload.get('iat', 0)),
                'expires_at': datetime.fromtimestamp(payload.get('exp', 0)),
                'jti': payload.get('jti'),
                'is_expired': datetime.utcnow() > datetime.fromtimestamp(payload.get('exp', 0))
            }

        except Exception as e:
            log_error("获取令牌信息失败", e)
            return None

    def cleanup_expired_blacklist(self):
        """清理过期的黑名单令牌"""
        # 在实际应用中，需要定期清理过期的令牌
        # 这里简化处理
        log_info("清理过期黑名单令牌")

    def get_stats(self) -> Dict[str, Any]:
        """获取令牌管理统计信息"""
        return {
            'blacklist_size': len(self.token_blacklist),
            'algorithm': self.algorithm,
            'default_access_expires': self.default_access_expires.total_seconds(),
            'default_refresh_expires': self.default_refresh_expires.total_seconds()
        }

    def cleanup(self):
        """清理资源"""
        try:
            self.token_blacklist.clear()
            log_info("TokenManager清理完成")
        except Exception as e:
            log_error("TokenManager清理失败", e)