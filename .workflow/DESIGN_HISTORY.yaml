# Claude Enhancer 设计决策历史档案
# 用途：记录"为什么"，防止遗忘初衷
# 更新：每次重大变更必须添加记录

version: "7.2.1"
last_updated: "2025-10-23"

# ═══════════════════════════════════════════════════════════
# 核心决策：为什么是7 Phases、97 Checkpoints、2 Gates？
# ═══════════════════════════════════════════════════════════

core_decisions:

  # 决策1：7 Phases工作流
  seven_phases:
    question: "为什么是7个Phase，而不是5个或10个？"
    decided_date: "2025-10-15"
    decided_version: "v6.3.0"
    decision: "从8个Phase优化到7个Phase"
    reasoning: |
      - 原8 Phase系统过于复杂（Phase 3-4重叠，Phase 7-8都是监控）
      - 7是完美数字：符合心理学"7±2原则"（人类短期记忆容量）
      - 覆盖完整软件生命周期：规划→实现→测试→审查→发布→验收→收尾
      - 2个质量门禁位置最优：Phase 3（技术）+ Phase 4（代码）
    alternatives_considered:
      - "5 Phase系统"：太简单，无法保证质量
      - "10 Phase系统"：太复杂，开发者记不住
    impact: "提升17%效率，零质量损失"

  # 决策2：97个Checkpoints
  ninety_seven_checkpoints:
    question: "为什么是97个检查点？这个数字怎么来的？"
    decided_date: "2025-09-20"
    decided_version: "v5.3.0"
    decision: "固定为97个，只能增加不能减少"
    reasoning: |
      - 经过3个月实战验证，97个点能cover 95%的bug
      - 分布符合软件开发规律：
        * Phase 1最多（33个）：前期规划决定80%成败
        * Phase 3-4各15/10个：质量门禁阶段
        * Phase 7最少（4个）：收尾阶段简单
      - 97 = 质数，心理学上更容易记住
      - 不是100：留出扩展空间，防止"凑整"心态
    calculation: |
      Phase 1: 33 = 5 (Branch) + 5 (Req) + 8 (Discovery) + 3 (Impact) + 12 (Planning)
      Phase 2: 15 = 基础实现检查
      Phase 3: 15 = 质量门禁1（自动化检查）
      Phase 4: 10 = 质量门禁2（人工审查）
      Phase 5: 15 = 发布准备
      Phase 6: 5 = 验收确认
      Phase 7: 4 = 最终清理
      总计: 97
    alternatives_considered:
      - "80个检查点"：测试后发现漏了关键检查
      - "120个检查点"：太多，AI和人都记不住
    impact: "发现bug提前到Phase 3-4，Phase 5发现bug从30%降到<10%"
    evidence: "PR #19案例：8个bug本应Phase 3发现，实际Phase 5才发现"

  # 决策3：2个质量门禁（不是1个或3个）
  two_quality_gates:
    question: "为什么只有2个质量门禁？为什么不是3个？"
    decided_date: "2025-08-15"
    decided_version: "v5.0.0"
    decision: "2个门禁：Phase 3技术质量 + Phase 4代码质量"
    reasoning: |
      - 左移测试原则：越早发现问题，修复成本越低
      - Gate 1（Phase 3）：100%自动化，快速反馈（<5分钟）
      - Gate 2（Phase 4）：自动化+人工，深度检查（~30分钟）
      - 不设Phase 5门禁：那时发现bug已经太晚
    alternatives_considered:
      - "1个门禁（Phase 4）"：太晚，很多简单bug到Phase 4才发现
      - "3个门禁（Phase 2/3/4）"：Phase 2太早，会阻碍快速迭代
    cost_benefit: |
      Gate 1成本：5分钟自动化
      Gate 1收益：拦截80%的技术债务
      Gate 2成本：30分钟（20分钟自动+10分钟人工）
      Gate 2收益：拦截15%的逻辑bug
      Phase 5剩余：<5%的边缘bug（可接受）

  # 决策4：8个硬性阻止（Hard Blocks）
  eight_hard_blocks:
    question: "为什么是8个Hard Block？"
    decided_date: "2025-09-01"
    decided_version: "v5.2.0"
    decision: "8个不可绕过的强制阻止条件"
    reasoning: |
      - 这8个是"最后防线"：违反=100%会出大问题
      - 不能太多：太多Hard Block会让开发者反感
      - 不能太少：关键风险必须阻止
    list:
      1. "Phase 1：未创建feature分支"
      2. "Phase 3：Shell语法错误"
      3. "Phase 3：函数复杂度>250行"
      4. "Phase 4：版本不一致"
      5. "Phase 4：存在critical TODO"
      6. "Phase 5：根目录文档>7个"
      7. "Phase 5：CHANGELOG未更新"
      8. "Phase 7：.temp目录>10MB"
    evolution: |
      v5.0.0: 5个Hard Blocks
      v5.2.0: 增加到8个（增加了版本一致性、文档清理、临时文件清理）
      v7.2.0: 保持8个（经验证这8个足够）

  # 决策5：可配置Lock模式（v7.2.0新增）
  configurable_lock_mode:
    question: "为什么LOCK模式设计成可配置（soft/strict）？"
    decided_date: "2025-10-23"
    decided_version: "v7.2.0"
    decision: "lock_mode可配置为soft或strict，默认soft"
    reasoning: |
      - 用户是长期用户（几年+），需要灵活性和稳定性的平衡
      - Soft模式：允许经过思考的改进，但会警告提醒用户review
      - Strict模式：绝对锁定，适用于需要100%稳定的场景
      - 可配置：给用户选择权，不同阶段可能需要不同策略
    default_choice: "soft"
    default_reasoning: |
      - 长期项目需要演进，完全锁死会限制合理改进
      - Max用户更在乎质量而非返工，soft模式提供了审查机会
      - 用户可以根据项目阶段切换模式（稳定期用strict，探索期用soft）
    implementation: |
      - SPEC.yaml定义lock_mode（单一数据源）
      - verify-core-structure.sh读取并执行不同行为
      - Soft模式：检测到变化→输出警告→exit 0（不阻止）
      - Strict模式：检测到变化→输出错误→exit 1（阻止PR）
    alternatives_considered:
      - "固定soft模式"：灵活但缺乏强制力
      - "固定strict模式"：稳定但过于僵硬
      - "可配置模式"：最佳平衡，采纳 ✅
    use_cases:
      soft_mode:
        - "开发阶段：需要快速迭代和实验"
        - "长期维护：允许优化但需要审查"
        - "单用户项目：用户自己决策，不需要强制阻止"
      strict_mode:
        - "生产稳定期：不允许任何core结构变化"
        - "团队协作：防止未经讨论的修改"
        - "关键发布前：锁定所有变更"
    evidence: |
      用户明确表态：
      - "我是长期用户，几年到更久"
      - "Max用户，不在乎token，在乎质量和不返工"
      - "希望有效率，但质量优先"
      → 这些需求完美匹配soft模式的设计理念

# ═══════════════════════════════════════════════════════════
# Feature演变历史：从0到12
# ═══════════════════════════════════════════════════════════

feature_evolution:

  # 当前Feature统计
  current_state:
    total_features: 12
    feature_list:
      - F001: "分支保护 (Branch Protection)"
      - F002: "工作流强制 (Workflow Enforcement)"
      - F003: "Agent智能选择 (Smart Agent Selection)"
      - F004: "质量门禁 (Quality Gates)"
      - F005: "Phase管理 (Phase Management)"
      - F006: "性能监控 (Performance Monitoring)"
      - F007: "BDD测试 (BDD Testing)"
      - F008: "文档管理 (Document Management)"
      - F009: "版本控制 (Version Control)"
      - F010: "缓存系统 (Caching System)"
      - F011: "错误恢复 (Error Recovery)"
      - F012: "自愈系统 (Self-Healing)"

  # 历史演变
  evolution_timeline:

    - version: "v1.0.0"
      date: "2024-05-01"
      features_count: 3
      features: ["F001", "F002", "F005"]
      milestone: "MVP - 基础工作流"

    - version: "v3.0.0"
      date: "2024-08-01"
      features_count: 6
      features: ["F001-F006"]
      milestone: "质量门禁引入"
      major_addition: "F004质量门禁系统"
      checkpoints_added: 20

    - version: "v5.0.0"
      date: "2024-11-01"
      features_count: 9
      features: ["F001-F009"]
      milestone: "生产就绪"
      major_addition: "F007 BDD测试 + F008文档管理"
      checkpoints_added: 15

    - version: "v6.0.0"
      date: "2025-01-15"
      features_count: 11
      features: ["F001-F011"]
      milestone: "专业级跨越"
      major_addition: "F010缓存系统 + F011错误恢复"
      checkpoints_added: 8

    - version: "v7.2.0"
      date: "2025-10-23"
      features_count: 12
      features: ["F001-F012"]
      milestone: "Dashboard v2 + 自愈系统"
      major_addition: "F012自愈系统 + 可视化Dashboard"
      checkpoints_added: 0  # Dashboard是工具，不增加workflow checkpoints

# ═══════════════════════════════════════════════════════════
# 如何安全扩展Feature
# ═══════════════════════════════════════════════════════════

feature_expansion_guide:

  principles:
    - "每增加1个feature，至少增加10-20个checkpoints"
    - "新feature必须过2个质量门禁"
    - "新feature必须有设计文档（WHY + HOW）"
    - "更新SPEC.yaml + LOCK.json"

  step_by_step_process:

    step1:
      name: "评估影响"
      actions:
        - "新feature属于哪个Phase？"
        - "影响半径多大？（使用Impact Assessment工具）"
        - "需要增加多少checkpoints？"

    step2:
      name: "设计检查点"
      actions:
        - "Phase 1增加：需求定义、技术探索检查点"
        - "Phase 3增加：单元测试、集成测试检查点"
        - "Phase 4增加：代码审查、文档审查检查点"

    step3:
      name: "更新SPEC.yaml"
      actions:
        - "更新total_checkpoints: 97 → 107（假设新增10个）"
        - "更新distribution分布"
        - "在DESIGN_HISTORY.yaml记录WHY"

    step4:
      name: "更新LOCK.json"
      actions:
        - "运行 bash tools/update-lock.sh"
        - "生成新的SHA256指纹"
        - "CI自动验证"

  example_new_feature:
    feature_id: "F013"
    feature_name: "AI自动调试 (AI Auto-Debugging)"
    decided_date: "2025-11-01"
    reasoning: "用户反馈：希望AI能自动修复简单bug"
    checkpoints_to_add: 18
    checkpoint_distribution:
      phase1: 5  # 需求定义、技术可行性、架构设计
      phase2: 3  # 实现检查
      phase3: 6  # 单元测试、性能测试、边界测试
      phase4: 2  # 代码审查、安全审查
      phase5: 2  # 发布文档、监控配置
    gates_update:
      gate1: "增加：AI调试性能测试（<1s响应）"
      gate2: "增加：AI调试代码审查（防止过度修复）"

# ═══════════════════════════════════════════════════════════
# 防止AI自我推翻的机制
# ═══════════════════════════════════════════════════════════

ai_self_modification_prevention:

  problem_statement: |
    AI编程的核心风险：
    - 这次A plan，下次B plan，自己推翻自己
    - 今天97个checkpoints，明天改成92，后天改成88
    - 不告诉用户就悄悄改动核心结构

  solution_layers:

    layer1_spec_lock:
      name: "SPEC.yaml核心锁定"
      protection: |
        ⛔ 标记不可改字段（total_phases, total_checkpoints, quality_gates）
        ⛔ AI修改需要在CHANGELOG明确说明理由
        ⛔ 用户未批准，CI自动拒绝

    layer2_file_fingerprint:
      name: "LOCK.json指纹验证"
      protection: |
        🔒 关键文件SHA256指纹
        🔒 修改=指纹变化=CI检测
        🔒 必须运行update-lock.sh + 人工确认

    layer3_design_history:
      name: "DESIGN_HISTORY.yaml决策档案"
      protection: |
        📚 记录所有"为什么"
        📚 AI改动时必须参考历史决策
        📚 违反历史决策=需要充分理由

    layer4_ci_verification:
      name: "CI自动验证"
      protection: |
        🤖 每次push运行 tools/verify-core-structure.sh
        🤖 发现不一致=CI失败=阻止merge
        🤖 Slack/Email通知用户

  enforcement_flow: |
    AI尝试修改checkpoints: 97 → 92
      ↓
    1. SPEC.yaml被改 → Git显示diff
    2. LOCK.json指纹不匹配 → verify-core-structure.sh报错
    3. CI检查失败 → PR被阻止
    4. 用户收到通知："AI尝试减少checkpoints，已被阻止"
      ↓
    用户决策：
      - 允许：手动运行update-lock.sh + 在DESIGN_HISTORY.yaml记录理由
      - 拒绝：rollback修改

# ═══════════════════════════════════════════════════════════
# 可视化需求：你提到的核心痛点
# ═══════════════════════════════════════════════════════════

visualization_requirements:

  pain_point: |
    "随着时间推移，我忘记当初为什么这样设计"
    "97个步骤当初怎么想的、现在怎么想的，我也不知道"

  solution: "设计决策可视化Dashboard"

  dashboard_pages:

    page1_design_timeline:
      name: "设计演变时间线"
      url: "/design-history"
      content:
        - "时间轴：v1.0 → v7.2.0的演变"
        - "每个版本：增加了什么feature、为什么增加"
        - "Checkpoints变化：从60 → 80 → 97"
        - "可点击查看详细决策理由"

    page2_checkpoint_map:
      name: "97个检查点地图"
      url: "/checkpoints-map"
      content:
        - "可视化：7个Phase + 97个Checkpoints分布"
        - "点击任意checkpoint：显示设计理由"
        - "示例：PD_S001 - 为什么需要这个检查？有什么历史？"

    page3_decision_archive:
      name: "决策档案馆"
      url: "/decisions"
      content:
        - "所有重大决策列表"
        - "每个决策：问题、答案、理由、替代方案、结果"
        - "搜索功能：按关键词查找历史决策"

    page4_feature_roadmap:
      name: "Feature演进路线图"
      url: "/features"
      content:
        - "当前12个features"
        - "每个feature：何时加入、为什么加入、影响范围"
        - "未来计划：F013-F020候选列表"

# ═══════════════════════════════════════════════════════════
# 元数据
# ═══════════════════════════════════════════════════════════

metadata:
  purpose: "防止遗忘设计初衷，给AI和人类提供历史参考"
  audience:
    - "用户：了解为什么这样设计"
    - "AI：修改前必须参考，避免自我推翻"
    - "新开发者：快速了解设计哲学"

  maintenance:
    update_frequency: "每次重大版本发布（vX.0.0）"
    who_updates: "主开发者 + AI（需人工审核）"

  integration:
    - "Dashboard可视化：显示在 /design-history 页面"
    - "CI检查：verify-core-structure.sh读取此文件"
    - "AI提示：CLAUDE.md引用此文件"

# ═══════════════════════════════════════════════════════════
# Security Decisions: Branch Protection
# ═══════════════════════════════════════════════════════════

security_decisions:

  # Decision: Fix Branch Protection Merge Loophole (v7.2.1)
  branch_protection_fix_20251023:
    question: "为什么发现并修复了分支保护的merge漏洞?"
    discovered_date: "2025-10-23"
    fixed_version: "v7.2.1"
    issue: "可以在main分支本地执行git merge，绕过分支保护"
    
    root_causes:
      cause_1:
        description: "Husky配置绕过"
        details: |
          - Git配置了core.hooksPath=.husky，但.husky/pre-commit不存在
          - 导致标准.git/hooks/pre-commit完全不执行
          - 结果：所有pre-commit检查被绕过
      
      cause_2:
        description: "pre-commit缺少分支检查"
        details: |
          - 即使hook执行，也没有检查当前分支
          - Git没有pre-merge hook，merge创建commit时才触发pre-commit
          - 结果：可以在main上执行git merge，只是push会被阻止
    
    solution:
      fix_1: "移除core.hooksPath配置，使用标准.git/hooks"
      fix_2: "在pre-commit开头(line 29-55)添加PROTECTED BRANCH CHECK"
      fix_3: "阻止所有main/master/production上的commit（包括merge commits）"
    
    verification:
      test_1: "✅ 直接在main上commit → BLOCKED"
      test_2: "✅ 在main上git merge → BLOCKED"
      test_3: "✅ 在feature分支commit → 正常工作"
    
    lesson_learned: |
      - 分支保护必须在pre-commit阶段检查，而不是pre-push
      - Git hooks配置(hooksPath)要定期审计
      - 安全机制需要多层验证（pre-commit + commit-msg + pre-push）
    
    impact: "100%本地分支保护，关闭安全漏洞"
