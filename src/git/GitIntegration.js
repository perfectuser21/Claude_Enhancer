/**
 * Claude Enhancer Plus - Git Integration Layer
 *
 * Unified interface for all Git optimizations
 * Integrates GitOptimizer, GitStatusCache, OptimizedHooks, and GitPerformanceMonitor
 */

const GitOptimizer = require('./GitOptimizer');
const GitStatusCache = require('./GitStatusCache');
const OptimizedHooks = require('./OptimizedHooks');
const GitPerformanceMonitor = require('./GitPerformanceMonitor');
const { EventEmitter } = require('events');
const fs = require('fs').promises;
const path = require('path');

class GitIntegration extends EventEmitter {
    constructor(repositoryPath = process.cwd(), options = {}) {
        super();

        this.repositoryPath = repositoryPath;
        this.options = {
            enableCaching: options.enableCaching !== false,
            enableMonitoring: options.enableMonitoring !== false,
            enableOptimizedHooks: options.enableOptimizedHooks !== false,
            enableBatching: options.enableBatching !== false,
            ...options
        };

        // ÂàùÂßãÂåñÁªÑ‰ª∂
        this.gitOptimizer = null;
        this.statusCache = null;
        this.optimizedHooks = null;
        this.performanceMonitor = null;

        // Áä∂ÊÄÅ
        this.initialized = false;
        this.ready = false;

        this.init();
    }

    async init() {
        try {
            console.log('üöÄ ÂàùÂßãÂåñClaude Enhancer Plus Git‰ºòÂåñÁ≥ªÁªü...');

            // 1. ÂàùÂßãÂåñGit‰ºòÂåñÂô®
            this.gitOptimizer = new GitOptimizer({
                repositoryPath: this.repositoryPath,
                ...this.options
            });

            // 2. ÂàùÂßãÂåñÁä∂ÊÄÅÁºìÂ≠ò
            if (this.options.enableCaching) {
                this.statusCache = new GitStatusCache(this.gitOptimizer, {
                    maxCacheAge: this.options.cacheMaxAge || 30000,
                    watchFiles: this.options.watchFiles !== false
                });
            }

            // 3. ÂàùÂßãÂåñÊÄßËÉΩÁõëÊéß
            if (this.options.enableMonitoring) {
                this.performanceMonitor = new GitPerformanceMonitor(this.gitOptimizer);

                // ÁõëÂê¨ÊÄßËÉΩ‰∫ã‰ª∂
                this.performanceMonitor.on('operation-end', (operation) => {
                    this.emit('performance-data', operation);
                });
            }

            // 4. ÂàùÂßãÂåñ‰ºòÂåñÁöÑHooks
            if (this.options.enableOptimizedHooks) {
                this.optimizedHooks = new OptimizedHooks(this.repositoryPath);
            }

            // 5. ËÆæÁΩÆÁªÑ‰ª∂Èó¥ÁöÑÈõÜÊàê
            this.setupIntegration();

            this.initialized = true;
            this.ready = true;

            console.log('‚úÖ Git‰ºòÂåñÁ≥ªÁªüÂàùÂßãÂåñÂÆåÊàê');
            this.emit('ready');

        } catch (error) {
            console.error('‚ùå Git‰ºòÂåñÁ≥ªÁªüÂàùÂßãÂåñÂ§±Ë¥•:', error.message);
            this.emit('error', error);
            throw error;
        }
    }

    /**
     * ËÆæÁΩÆÁªÑ‰ª∂Èó¥ÁöÑÈõÜÊàê
     */
    setupIntegration() {
        // ÈõÜÊàêÊÄßËÉΩÁõëÊéßÂà∞Git‰ºòÂåñÂô®
        if (this.performanceMonitor && this.gitOptimizer) {
            const originalExecuteGitCommand = this.gitOptimizer.executeGitCommand.bind(this.gitOptimizer);

            this.gitOptimizer.executeGitCommand = async (command, options = {}) => {
                const operationId = this.performanceMonitor.startOperation('git-command', {
                    command: command.split(' ')[0] // Âè™ËÆ∞ÂΩïÂëΩ‰ª§Âêç
                });

                try {
                    const result = await originalExecuteGitCommand(command, options);
                    this.performanceMonitor.endOperation(operationId, { success: true });
                    return result;
                } catch (error) {
                    this.performanceMonitor.endOperation(operationId, { error: error.message });
                    throw error;
                }
            };
        }

        // ÈõÜÊàêÁºìÂ≠ò‰∫ã‰ª∂Âà∞ÊÄßËÉΩÁõëÊéß
        if (this.statusCache && this.performanceMonitor) {
            this.statusCache.on('cache-hit', (event) => {
                this.emit('cache-performance', { type: 'hit', ...event });
            });

            this.statusCache.on('cache-miss', (event) => {
                this.emit('cache-performance', { type: 'miss', ...event });
            });
        }
    }

    /**
     * Áªü‰∏ÄÁöÑGitÁä∂ÊÄÅÊü•ËØ¢Êé•Âè£
     */
    async getStatus(options = {}) {
        this.ensureReady();

        const startTime = Date.now();
        let operationId = null;

        try {
            if (this.performanceMonitor) {
                operationId = this.performanceMonitor.startOperation('unified-status', options);
            }

            let result;

            if (options.files && options.files.length > 0) {
                // Êñá‰ª∂ÁâπÂÆöÁä∂ÊÄÅÊü•ËØ¢
                if (this.statusCache) {
                    result = await this.statusCache.getBatchFileStatus(options.files, options.forceRefresh);
                } else {
                    result = await this.gitOptimizer.getBatchedStatus(options.files);
                }
            } else {
                // ÂÖ®Â±ÄÁä∂ÊÄÅÊü•ËØ¢
                if (this.statusCache) {
                    result = await this.statusCache.getGlobalStatus(options.forceRefresh);
                } else {
                    result = await this.gitOptimizer.getBatchedStatus();
                }
            }

            const duration = Date.now() - startTime;

            if (operationId) {
                this.performanceMonitor.endOperation(operationId, {
                    success: true,
                    filesProcessed: options.files?.length || 'all'
                });
            }

            this.emit('status-query', { duration, result, options });
            return result;

        } catch (error) {
            if (operationId) {
                this.performanceMonitor.endOperation(operationId, { error: error.message });
            }

            this.emit('status-error', { error, options });
            throw error;
        }
    }

    /**
     * Áªü‰∏ÄÁöÑÊñá‰ª∂Ê∑ªÂä†Êé•Âè£
     */
    async addFiles(files, options = {}) {
        this.ensureReady();

        const startTime = Date.now();
        let operationId = null;

        try {
            if (this.performanceMonitor) {
                operationId = this.performanceMonitor.startOperation('unified-add', {
                    fileCount: files.length,
                    ...options
                });
            }

            const result = await this.gitOptimizer.batchAdd(files);
            const duration = Date.now() - startTime;

            if (operationId) {
                this.performanceMonitor.endOperation(operationId, {
                    success: result.success,
                    filesAdded: result.addedFiles?.length || 0
                });
            }

            // Ê∏ÖÈô§Áä∂ÊÄÅÁºìÂ≠ò
            if (this.statusCache) {
                this.statusCache.invalidateGlobalCache();
                files.forEach(file => this.statusCache.invalidateFileCache(file));
            }

            this.emit('files-added', { result, duration, files });
            return result;

        } catch (error) {
            if (operationId) {
                this.performanceMonitor.endOperation(operationId, { error: error.message });
            }

            this.emit('add-error', { error, files });
            throw error;
        }
    }

    /**
     * ÊâßË°å‰ºòÂåñÁöÑpre-commitÊ£ÄÊü•
     */
    async runPreCommitChecks(options = {}) {
        this.ensureReady();

        if (!this.optimizedHooks) {
            throw new Error('‰ºòÂåñHooksÊú™ÂêØÁî®');
        }

        const startTime = Date.now();
        let operationId = null;

        try {
            if (this.performanceMonitor) {
                operationId = this.performanceMonitor.startOperation('pre-commit-checks', options);
            }

            const result = await this.optimizedHooks.executePreCommit();
            const duration = Date.now() - startTime;

            if (operationId) {
                this.performanceMonitor.endOperation(operationId, {
                    success: result.success,
                    checksRun: 'all'
                });
            }

            this.emit('pre-commit-result', { result, duration });
            return result;

        } catch (error) {
            if (operationId) {
                this.performanceMonitor.endOperation(operationId, { error: error.message });
            }

            this.emit('pre-commit-error', { error });
            throw error;
        }
    }

    /**
     * Ëé∑ÂèñÂàÜÊîØ‰ø°ÊÅØ
     */
    async getBranchInfo(options = {}) {
        this.ensureReady();

        const operationId = this.performanceMonitor?.startOperation('branch-info', options);

        try {
            const result = await this.gitOptimizer.getBranchInfo();

            if (operationId) {
                this.performanceMonitor.endOperation(operationId, { success: true });
            }

            return result;

        } catch (error) {
            if (operationId) {
                this.performanceMonitor.endOperation(operationId, { error: error.message });
            }

            throw error;
        }
    }

    /**
     * Ëé∑ÂèñÊèê‰∫§ÂéÜÂè≤
     */
    async getCommitHistory(options = {}) {
        this.ensureReady();

        const operationId = this.performanceMonitor?.startOperation('commit-history', options);

        try {
            const result = await this.gitOptimizer.getCommitHistory(options);

            if (operationId) {
                this.performanceMonitor.endOperation(operationId, {
                    success: true,
                    commitsRetrieved: result.length
                });
            }

            return result;

        } catch (error) {
            if (operationId) {
                this.performanceMonitor.endOperation(operationId, { error: error.message });
            }

            throw error;
        }
    }

    /**
     * Êô∫ËÉΩÂ∑ÆÂºÇÊ£ÄÊü•
     */
    async getDiff(options = {}) {
        this.ensureReady();

        const operationId = this.performanceMonitor?.startOperation('intelligent-diff', options);

        try {
            const result = await this.gitOptimizer.getIntelligentDiff(options);

            if (operationId) {
                this.performanceMonitor.endOperation(operationId, { success: true });
            }

            return result;

        } catch (error) {
            if (operationId) {
                this.performanceMonitor.endOperation(operationId, { error: error.message });
            }

            throw error;
        }
    }

    /**
     * Ëé∑ÂèñÁªºÂêàÊÄßËÉΩÊä•Âëä
     */
    getPerformanceReport() {
        this.ensureReady();

        const report = {
            timestamp: Date.now(),
            system: {
                initialized: this.initialized,
                ready: this.ready,
                components: {
                    gitOptimizer: !!this.gitOptimizer,
                    statusCache: !!this.statusCache,
                    optimizedHooks: !!this.optimizedHooks,
                    performanceMonitor: !!this.performanceMonitor
                }
            },
            optimizer: this.gitOptimizer?.getPerformanceStats() || null,
            cache: this.statusCache?.getStats() || null,
            hooks: this.optimizedHooks?.getPerformanceStats() || null,
            monitor: this.performanceMonitor?.getPerformanceReport() || null
        };

        return report;
    }

    /**
     * ‰ºòÂåñÂª∫ËÆÆ
     */
    getOptimizationSuggestions() {
        const suggestions = [];

        // ÁºìÂ≠òÂª∫ËÆÆ
        if (this.statusCache) {
            const cacheStats = this.statusCache.getStats();
            if (cacheStats.hitRate && parseFloat(cacheStats.hitRate) < 60) {
                suggestions.push({
                    type: 'caching',
                    priority: 'high',
                    message: 'Áä∂ÊÄÅÁºìÂ≠òÂëΩ‰∏≠ÁéáËæÉ‰ΩéÔºåÂª∫ËÆÆÂ¢ûÂä†ÁºìÂ≠òÊó∂Èó¥Êàñ‰ºòÂåñÊü•ËØ¢Ê®°Âºè',
                    action: 'Ë∞ÉÊï¥maxCacheAgeÂèÇÊï∞ÊàñÂáèÂ∞ëforceRefreshË∞ÉÁî®'
                });
            }
        }

        // ÊÄßËÉΩÁõëÊéßÂª∫ËÆÆ
        if (this.performanceMonitor) {
            const monitorReport = this.performanceMonitor.getPerformanceReport();
            if (monitorReport.optimization.suggestions) {
                suggestions.push(...monitorReport.optimization.suggestions.map(s => ({
                    ...s,
                    source: 'performance-monitor'
                })));
            }
        }

        return suggestions;
    }

    /**
     * ÂØºÂá∫ÈÖçÁΩÆÁî®‰∫éhookËÑöÊú¨
     */
    async exportConfigForHooks() {
        const config = {
            optimizerAvailable: !!this.gitOptimizer,
            cacheAvailable: !!this.statusCache,
            hooksAvailable: !!this.optimizedHooks,
            monitoringEnabled: !!this.performanceMonitor,
            repositoryPath: this.repositoryPath,
            options: this.options
        };

        const configPath = path.join(this.repositoryPath, '.claude', 'git-integration-config.json');
        await fs.writeFile(configPath, JSON.stringify(config, null, 2));

        return configPath;
    }

    /**
     * Á°Æ‰øùÁ≥ªÁªüÂ∑≤Â∞±Áª™
     */
    ensureReady() {
        if (!this.ready) {
            throw new Error('Git‰ºòÂåñÁ≥ªÁªüÂ∞öÊú™Â∞±Áª™ÔºåËØ∑Á≠âÂæÖÂàùÂßãÂåñÂÆåÊàê');
        }
    }

    /**
     * ÂÅ•Â∫∑Ê£ÄÊü•
     */
    async healthCheck() {
        const health = {
            overall: 'healthy',
            components: {},
            issues: []
        };

        try {
            // Ê£ÄÊü•Git‰ºòÂåñÂô®
            if (this.gitOptimizer) {
                const gitStats = await this.gitOptimizer.getPerformanceStats();
                health.components.gitOptimizer = {
                    status: 'healthy',
                    cacheSize: gitStats.cacheSize,
                    uptime: gitStats.uptime
                };
            }

            // Ê£ÄÊü•Áä∂ÊÄÅÁºìÂ≠ò
            if (this.statusCache) {
                const cacheStats = this.statusCache.getStats();
                health.components.statusCache = {
                    status: 'healthy',
                    cacheSize: cacheStats.cacheSize,
                    watchers: cacheStats.watchers
                };
            }

            // Ê£ÄÊü•ÊÄßËÉΩÁõëÊéß
            if (this.performanceMonitor) {
                const monitorStats = this.performanceMonitor.getPerformanceReport();
                health.components.performanceMonitor = {
                    status: 'healthy',
                    totalOperations: monitorStats.summary.totalOperations,
                    activeOperations: monitorStats.summary.currentOperations
                };
            }

            // Ê£ÄÊü•‰ºòÂåñHooks
            if (this.optimizedHooks) {
                const hooksStats = this.optimizedHooks.getPerformanceStats();
                health.components.optimizedHooks = {
                    status: 'healthy',
                    totalRuns: hooksStats.totalRuns,
                    fastExits: hooksStats.fastExits
                };
            }

        } catch (error) {
            health.overall = 'degraded';
            health.issues.push(`ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•: ${error.message}`);
        }

        return health;
    }

    /**
     * Ê∏ÖÁêÜÊâÄÊúâËµÑÊ∫ê
     */
    cleanup() {
        console.log('üßπ Ê∏ÖÁêÜGit‰ºòÂåñÁ≥ªÁªüËµÑÊ∫ê...');

        if (this.gitOptimizer) {
            this.gitOptimizer.cleanup();
        }

        if (this.statusCache) {
            this.statusCache.cleanup();
        }

        if (this.optimizedHooks) {
            this.optimizedHooks.cleanup();
        }

        if (this.performanceMonitor) {
            this.performanceMonitor.cleanup();
        }

        this.removeAllListeners();
        this.ready = false;

        console.log('‚úÖ ËµÑÊ∫êÊ∏ÖÁêÜÂÆåÊàê');
    }
}

module.exports = GitIntegration;