#!/bin/bash
# Push with Retry - Network Failure Resilience
# Claude Enhancer 5.0 - Git Workflow Automation

set -euo pipefail

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'

# Configuration
readonly MAX_RETRIES=3
readonly RETRY_DELAY=5
readonly OFFLINE_STATE_FILE=".workflow/_offline_state.json"

# ==================== Push with Retry ====================

push_with_retry() {
    local branch="${1:-$(git branch --show-current)}"
    local force="${2:-false}"
    local attempt=1

    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${CYAN}  üì§ Git Push with Network Retry${NC}"
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo ""
    echo "ÂàÜÊîØ: ${branch}"
    echo "ÊúÄÂ§ßÈáçËØï: ${MAX_RETRIES}"
    echo ""

    while [[ $attempt -le $MAX_RETRIES ]]; do
        echo -e "${YELLOW}[Â∞ùËØï ${attempt}/${MAX_RETRIES}]${NC} Êé®ÈÄÅÂà∞ËøúÁ®ã..."

        local push_cmd="git push"
        if [[ "$force" == "true" ]]; then
            push_cmd="git push --force-with-lease"
            echo -e "${YELLOW}‚ö†Ô∏è  ‰ΩøÁî® force-with-lease Ê®°Âºè${NC}"
        fi

        # Set upstream if not tracking
        if ! git config "branch.${branch}.remote" > /dev/null 2>&1; then
            push_cmd="git push -u origin ${branch}"
            echo -e "${CYAN}ËÆæÁΩÆ‰∏äÊ∏∏Ë∑üË∏™: origin/${branch}${NC}"
        fi

        # Execute push
        if eval "$push_cmd" 2>&1 | tee .workflow/temp/push.log; then
            echo ""
            echo -e "${GREEN}‚úÖ Êé®ÈÄÅÊàêÂäüÔºÅ${NC}"
            echo ""

            # Show remote info
            show_remote_info "$branch"

            # Clean up offline state if exists
            [[ -f "$OFFLINE_STATE_FILE" ]] && rm -f "$OFFLINE_STATE_FILE"

            return 0
        fi

        # Push failed
        local error_msg=$(cat .workflow/temp/push.log 2>/dev/null | tail -5)

        echo ""
        echo -e "${RED}‚ùå Êé®ÈÄÅÂ§±Ë¥•${NC}"
        echo "ÈîôËØØ‰ø°ÊÅØ:"
        echo "$error_msg" | sed 's/^/  /'
        echo ""

        # Analyze failure reason
        local failure_reason=$(analyze_failure "$error_msg")

        case "$failure_reason" in
            "network")
                if [[ $attempt -lt $MAX_RETRIES ]]; then
                    echo -e "${YELLOW}ÁΩëÁªúÈîôËØØÔºå${RETRY_DELAY}ÁßíÂêéÈáçËØï...${NC}"
                    sleep $RETRY_DELAY
                fi
                ;;
            "rejected")
                echo -e "${RED}Êé®ÈÄÅË¢´ÊãíÁªùÔºàËøúÁ®ãÊúâÊñ∞Êèê‰∫§Ôºâ${NC}"
                echo ""
                echo "Âª∫ËÆÆÊìç‰Ωú:"
                echo "  1. ÊãâÂèñËøúÁ®ãÊõ¥Êñ∞: git pull --rebase origin ${branch}"
                echo "  2. Ëß£ÂÜ≥ÂÜ≤Á™ÅÔºàÂ¶ÇÊûúÊúâÔºâ"
                echo "  3. ÈáçÊñ∞Êé®ÈÄÅ: bash $0 ${branch}"
                return 1
                ;;
            "permission")
                echo -e "${RED}ÊùÉÈôê‰∏çË∂≥${NC}"
                echo ""
                echo "Âª∫ËÆÆÊìç‰Ωú:"
                echo "  1. Ê£ÄÊü• SSH ÂØÜÈí•: ssh -T git@github.com"
                echo "  2. Á°ÆËÆ§‰ªìÂ∫ìÂÜôÊùÉÈôê"
                echo "  3. ËÅîÁ≥ª‰ªìÂ∫ìÁÆ°ÁêÜÂëò"
                return 1
                ;;
            "size")
                echo -e "${RED}Êé®ÈÄÅÂÜÖÂÆπËøáÂ§ß${NC}"
                echo ""
                echo "Âª∫ËÆÆÊìç‰Ωú:"
                echo "  1. Ê£ÄÊü•ÊòØÂê¶ÊúâÂ§ßÊñá‰ª∂: git ls-files -z | xargs -0 du -h | sort -rh | head -20"
                echo "  2. ‰ΩøÁî® Git LFS: git lfs track '*.bin'"
                echo "  3. ÂàÜÊâπÊé®ÈÄÅ: git push origin HEAD~N:${branch}"
                return 1
                ;;
            *)
                echo -e "${YELLOW}Êú™Áü•ÈîôËØØ${NC}"
                ;;
        esac

        ((attempt++))
    done

    # All retries failed
    echo ""
    echo -e "${RED}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${RED}  ‚ùå Êé®ÈÄÅÂ§±Ë¥•ÔºàÂ∑≤ÈáçËØï ${MAX_RETRIES} Ê¨°Ôºâ${NC}"
    echo -e "${RED}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo ""

    # Save offline state
    echo -e "${CYAN}üíæ ‰øùÂ≠òÁ¶ªÁ∫øÁä∂ÊÄÅ...${NC}"
    save_offline_state "$branch"

    echo ""
    echo -e "${YELLOW}ÂêéÁª≠Êìç‰Ωú:${NC}"
    echo "  1. Ê£ÄÊü•ÁΩëÁªúËøûÊé•"
    echo "  2. ÁΩëÁªúÊÅ¢Â§çÂêéËøêË°å: bash scripts/resume_publish.sh"
    echo "  3. ÊàñÊâãÂä®Êé®ÈÄÅ: git push origin ${branch}"
    echo ""

    return 1
}

# ==================== Failure Analysis ====================

analyze_failure() {
    local error_msg="$1"

    # Network errors
    if echo "$error_msg" | grep -qiE "(network|connection|timeout|could not resolve|failed to connect)"; then
        echo "network"
        return
    fi

    # Rejected (non-fast-forward)
    if echo "$error_msg" | grep -qiE "(rejected|non-fast-forward|fetch first)"; then
        echo "rejected"
        return
    fi

    # Permission denied
    if echo "$error_msg" | grep -qiE "(permission denied|authentication failed|access denied)"; then
        echo "permission"
        return
    fi

    # Size limit exceeded
    if echo "$error_msg" | grep -qiE "(size.*exceeded|too large|pack.*too big)"; then
        echo "size"
        return
    fi

    echo "unknown"
}

# ==================== Offline State Management ====================

save_offline_state() {
    local branch="$1"

    mkdir -p "$(dirname "$OFFLINE_STATE_FILE")"

    cat > "$OFFLINE_STATE_FILE" << EOF
{
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "branch": "${branch}",
    "phase": "$(cat .phase/current 2>/dev/null || echo 'Unknown')",
    "last_commit": "$(git rev-parse HEAD)",
    "commits_ahead": $(git rev-list --count @{u}..HEAD 2>/dev/null || echo 0),
    "quality_score": "$(cat .workflow/_reports/quality_score.txt 2>/dev/null || echo 'N/A')",
    "pending_action": "push_and_create_pr",
    "remote_url": "$(git config --get remote.origin.url)"
}
EOF

    echo "Á¶ªÁ∫øÁä∂ÊÄÅÂ∑≤‰øùÂ≠òÂà∞: ${OFFLINE_STATE_FILE}"
    echo ""
    echo "Áä∂ÊÄÅÂø´ÁÖß:"
    cat "$OFFLINE_STATE_FILE" | python3 -m json.tool 2>/dev/null || cat "$OFFLINE_STATE_FILE"
}

resume_from_offline() {
    if [[ ! -f "$OFFLINE_STATE_FILE" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Êó†Á¶ªÁ∫øÁä∂ÊÄÅÊñá‰ª∂${NC}"
        return 1
    fi

    echo -e "${CYAN}üìÇ Âä†ËΩΩÁ¶ªÁ∫øÁä∂ÊÄÅ...${NC}"
    echo ""

    # Parse JSON
    local branch=$(cat "$OFFLINE_STATE_FILE" | python3 -c "import sys,json; print(json.load(sys.stdin)['branch'])" 2>/dev/null)
    local saved_time=$(cat "$OFFLINE_STATE_FILE" | python3 -c "import sys,json; print(json.load(sys.stdin)['timestamp'])" 2>/dev/null)

    echo "ÂàÜÊîØ: ${branch}"
    echo "‰øùÂ≠òÊó∂Èó¥: ${saved_time}"
    echo ""

    # Verify current state
    local current_branch=$(git branch --show-current)
    if [[ "$current_branch" != "$branch" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  ÂΩìÂâçÂàÜÊîØ (${current_branch}) ‰∏é‰øùÂ≠òÁöÑÂàÜÊîØ (${branch}) ‰∏ç‰∏ÄËá¥${NC}"
        read -p "ÊòØÂê¶ÂàáÊç¢Âà∞ ${branch}? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            git checkout "$branch"
        else
            echo "Êìç‰ΩúÂèñÊ∂à"
            return 1
        fi
    fi

    # Test network
    echo "ÊµãËØïÁΩëÁªúËøûÊé•..."
    if ! timeout 5 git ls-remote origin HEAD > /dev/null 2>&1; then
        echo -e "${RED}‚ùå ÁΩëÁªú‰ªçÁÑ∂‰∏çÂèØÁî®${NC}"
        return 1
    fi

    echo -e "${GREEN}‚úÖ ÁΩëÁªúÂ∑≤ÊÅ¢Â§ç${NC}"
    echo ""

    # Resume push
    push_with_retry "$branch"
}

# ==================== Remote Info Display ====================

show_remote_info() {
    local branch="$1"

    echo -e "${GREEN}üìä ËøúÁ®ãÂàÜÊîØ‰ø°ÊÅØ${NC}"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

    # Remote URL
    local remote_url=$(git config --get remote.origin.url)
    echo "ËøúÁ®ã‰ªìÂ∫ì: ${remote_url}"

    # Tracking info
    local upstream=$(git config --get "branch.${branch}.merge" 2>/dev/null || echo "N/A")
    echo "‰∏äÊ∏∏ÂàÜÊîØ: ${upstream}"

    # Commits ahead/behind
    if git rev-parse @{u} > /dev/null 2>&1; then
        local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo 0)
        local behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo 0)

        if [[ $ahead -eq 0 && $behind -eq 0 ]]; then
            echo -e "Áä∂ÊÄÅ: ${GREEN}ÂêåÊ≠•${NC}"
        elif [[ $ahead -gt 0 && $behind -eq 0 ]]; then
            echo -e "Áä∂ÊÄÅ: ${YELLOW}È¢ÜÂÖà ${ahead} ‰∏™Êèê‰∫§${NC}"
        elif [[ $ahead -eq 0 && $behind -gt 0 ]]; then
            echo -e "Áä∂ÊÄÅ: ${YELLOW}ËêΩÂêé ${behind} ‰∏™Êèê‰∫§${NC}"
        else
            echo -e "Áä∂ÊÄÅ: ${RED}ÂàÜÂèâ (È¢ÜÂÖà ${ahead}, ËêΩÂêé ${behind})${NC}"
        fi
    else
        echo "Áä∂ÊÄÅ: Êó†‰∏äÊ∏∏Ë∑üË∏™"
    fi

    echo ""
}

# ==================== Network Test ====================

test_network() {
    echo -e "${CYAN}üîç ÊµãËØïÁΩëÁªúËøûÊé•...${NC}"
    echo ""

    # Test DNS
    echo -n "DNS Ëß£Êûê: "
    if timeout 3 host github.com > /dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ${NC}"
    else
        echo -e "${RED}‚ùå${NC}"
        return 1
    fi

    # Test HTTPS
    echo -n "HTTPS ËøûÊé•: "
    if timeout 5 curl -sI https://github.com > /dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ${NC}"
    else
        echo -e "${RED}‚ùå${NC}"
        return 1
    fi

    # Test SSH
    echo -n "SSH ËøûÊé•: "
    if timeout 5 ssh -T git@github.com 2>&1 | grep -q "successfully authenticated"; then
        echo -e "${GREEN}‚úÖ${NC}"
    else
        echo -e "${RED}‚ùå${NC}"
        return 1
    fi

    # Test Git remote
    echo -n "Git ËøúÁ®ã: "
    if timeout 5 git ls-remote origin HEAD > /dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ${NC}"
    else
        echo -e "${RED}‚ùå${NC}"
        return 1
    fi

    echo ""
    echo -e "${GREEN}‚úÖ ÁΩëÁªúËøûÊé•Ê≠£Â∏∏${NC}"
    return 0
}

# ==================== Usage Help ====================

show_usage() {
    cat << EOF
${CYAN}Push with Retry - Network Failure Resilience${NC}

Áî®Ê≥ï:
  $0 [branch] [options]

ÂèÇÊï∞:
  branch         ÁõÆÊ†áÂàÜÊîØÔºàÈªòËÆ§ÂΩìÂâçÂàÜÊîØÔºâ
  --force        ‰ΩøÁî® --force-with-lease Êé®ÈÄÅ
  --resume       ‰ªéÁ¶ªÁ∫øÁä∂ÊÄÅÊÅ¢Â§ç
  --test         ÊµãËØïÁΩëÁªúËøûÊé•

Á§∫‰æã:
  $0                           # Êé®ÈÄÅÂΩìÂâçÂàÜÊîØ
  $0 feature/P3-auth           # Êé®ÈÄÅÊåáÂÆöÂàÜÊîØ
  $0 --force                   # Âº∫Âà∂Êé®ÈÄÅÔºàÂÆâÂÖ®Ê®°ÂºèÔºâ
  $0 --resume                  # ÁΩëÁªúÊÅ¢Â§çÂêéÁªßÁª≠
  $0 --test                    # ÊµãËØïÁΩëÁªú

ÈÖçÁΩÆ:
  MAX_RETRIES=${MAX_RETRIES}      # ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞
  RETRY_DELAY=${RETRY_DELAY}      # ÈáçËØïÂª∂ËøüÔºàÁßíÔºâ

Á¶ªÁ∫øÁä∂ÊÄÅÊñá‰ª∂:
  ${OFFLINE_STATE_FILE}

EOF
}

# ==================== Entry Point ====================

main() {
    mkdir -p .workflow/temp

    case "${1:-}" in
        --help|-h)
            show_usage
            exit 0
            ;;
        --resume)
            resume_from_offline
            exit $?
            ;;
        --test)
            test_network
            exit $?
            ;;
        --force)
            push_with_retry "$(git branch --show-current)" "true"
            exit $?
            ;;
        *)
            push_with_retry "$@"
            exit $?
            ;;
    esac
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
