#!/bin/bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# IRONCLAD PRE-PUSH HOOK (UNBYPASSABLE)
# Claude Enhancer 5.0 - Security Hardened Version
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

PROJECT_ROOT="$(git rev-parse --show-toplevel)"

echo -e "${BOLD}ğŸ”’ Claude Enhancer - Ironclad Pre-Push Check${NC}"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BYPASS DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

echo -e "\n${CYAN}[BYPASS DETECTION]${NC}"

# Check for environment variable bypass attempts
if [ "${GIT_HOOKS_SKIP:-}" = "1" ] || \
   [ "${SKIP_HOOKS:-}" = "1" ] || \
   [ "${GIT_SKIP_HOOKS:-}" = "true" ]; then
    echo -e "${RED}âŒ ERROR: Hook bypass attempt detected!${NC}"
    echo "Environment variables cannot disable push hooks."
    exit 1
fi

# Check if hooksPath has been tampered
HOOKS_PATH=$(git config --get core.hooksPath 2>/dev/null || echo ".git/hooks")
if [[ "$HOOKS_PATH" != ".git/hooks" ]] && [[ -n "$HOOKS_PATH" ]]; then
    echo -e "${RED}âŒ ERROR: core.hooksPath has been modified to: $HOOKS_PATH${NC}"
    echo "This is a security violation!"
    exit 1
fi

echo -e "${GREEN}âœ“ No bypass attempts detected${NC}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CURRENT BRANCH PROTECTION (Precise Matching)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

echo -e "\n${CYAN}[BRANCH PROTECTION]${NC}"

CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Precise regex: only match exact protected branch names
if [[ "$CURRENT_BRANCH" =~ ^(main|master|production)$ ]]; then
    echo -e "${RED}âŒ ERROR: Cannot push from protected branch '$CURRENT_BRANCH'${NC}"
    echo ""
    echo -e "${YELLOW}Switch to a feature branch:${NC}"
    echo "  git checkout -b feature/your-feature-name"
    echo "  git push origin feature/your-feature-name"
    exit 1
fi

echo -e "${GREEN}âœ“ Current branch: $CURRENT_BRANCH (safe to push)${NC}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PUSH TARGET PROTECTION (Read stdin from git)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

echo -e "\n${CYAN}[PUSH TARGET VALIDATION]${NC}"

PROTECTED_REFS_BLOCKED=0

# Read push information from stdin (with timeout to avoid hanging)
while IFS=' ' read -t 1 local_ref local_sha remote_ref remote_sha 2>/dev/null; do
    # Extract branch name from refs/heads/branch_name
    if [[ "$remote_ref" =~ ^refs/heads/(.+)$ ]]; then
        target_branch="${BASH_REMATCH[1]}"
        
        # Precise check: only block exact protected branch names
        if [[ "$target_branch" =~ ^(main|master|production)$ ]]; then
            echo -e "${RED}âŒ ERROR: Cannot push to protected branch '$target_branch'${NC}"
            echo "   Push target: $local_ref â†’ $remote_ref"
            ((PROTECTED_REFS_BLOCKED++))
        fi
    fi
done || true  # Don't fail if stdin is empty (e.g., --dry-run)

if [ $PROTECTED_REFS_BLOCKED -gt 0 ]; then
    echo ""
    echo -e "${YELLOW}Use Pull Request workflow:${NC}"
    echo "  1. Push to feature branch:"
    echo "     git push origin HEAD:feature/your-feature"
    echo "  2. Create Pull Request on GitHub"
    echo "  3. Merge after code review"
    exit 1
fi

echo -e "${GREEN}âœ“ Push target validated${NC}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RE-RUN PRE-COMMIT CHECKS (Defense in depth)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

echo -e "\n${CYAN}[SECURITY RE-SCAN]${NC}"

# Re-run critical security checks
RECENT_COMMITS=$(git log --since="1 hour ago" --format="%H" 2>/dev/null | head -5)

if [ -n "$RECENT_COMMITS" ]; then
    SECURITY_ISSUES=0
    
    while IFS= read -r commit; do
        [ -z "$commit" ] && continue
        
        # Scan commit diff for secrets
        commit_diff=$(git show "$commit" --format="" 2>/dev/null || true)
        
        # Check for private keys
        if echo "$commit_diff" | grep -qE '^\+.*-----BEGIN (RSA |DSA |EC )?PRIVATE KEY'; then
            echo -e "${RED}âŒ Private key found in commit: ${commit:0:8}${NC}"
            ((SECURITY_ISSUES++))
        fi
        
        # Check for AWS keys
        if echo "$commit_diff" | grep -qE '^\+.*AKIA[0-9A-Z]{16}'; then
            echo -e "${RED}âŒ AWS key found in commit: ${commit:0:8}${NC}"
            ((SECURITY_ISSUES++))
        fi
    done <<< "$RECENT_COMMITS"
    
    if [ $SECURITY_ISSUES -gt 0 ]; then
        echo -e "${RED}âŒ CRITICAL: Security issues in recent commits!${NC}"
        echo "Remove sensitive data before pushing:"
        echo "  git reset --soft HEAD~1"
        echo "  # Remove secrets"
        echo "  git commit"
        exit 1
    fi
    
    echo -e "${GREEN}âœ“ Security re-scan passed${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONCURRENT SAFETY (If test exists)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if [ -f "$PROJECT_ROOT/test/stress/test_concurrent_operations.sh" ]; then
    echo -e "\n${CYAN}[CONCURRENT SAFETY]${NC}"
    
    if timeout 30s bash "$PROJECT_ROOT/test/stress/test_concurrent_operations.sh" &> /dev/null; then
        echo -e "${GREEN}âœ“ Concurrent safety validated${NC}"
    else
        echo -e "${YELLOW}âš ï¸  Concurrent safety test failed or timed out${NC}"
        # Non-blocking warning
    fi
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMPLETION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo -e "${GREEN}${BOLD}âœ… PRE-PUSH VALIDATION PASSED${NC}"
echo -e "${BLUE}Safe to push from: $CURRENT_BRANCH${NC}"

exit 0
