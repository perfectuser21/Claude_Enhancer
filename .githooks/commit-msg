#!/bin/bash

# === 自动模式支持 ===
if [[ -f "$HOME/dev/Claude Enhancer 5.0/.claude/auto.config" ]]; then
    source "$HOME/dev/Claude Enhancer 5.0/.claude/auto.config"
fi

# 如果是自动模式，跳过所有交互
if [[ "$GIT_HOOKS_AUTO_MODE" == "true" ]]; then
    # 覆盖read命令
    read() {
        if [[ "$1" == "-r" ]]; then
            shift
            eval "$1='y'"
        else
            eval "$1='y'"
        fi
        return 0
    }
fi
# === 自动模式结束 ===

# Claude Enhancer 5.0 - Commit Message Hook with Workflow/Phase validation
commit_file="$1"

set -euo pipefail

# ═══════════════════════════════════════
# 阶段0: 权限自检机制（最高优先级）
# ═══════════════════════════════════════

# 项目根目录
PROJECT_ROOT="$(git rev-parse --show-toplevel)"
HOOKS_DIR="$PROJECT_ROOT/.git/hooks"
LOG_DIR="$PROJECT_ROOT/.workflow/logs"
mkdir -p "$LOG_DIR"

# 权限自检函数
check_self_permission() {
    # 检查自身是否可执行
    if [ ! -x "$0" ]; then
        echo "🚨 CRITICAL: commit-msg hook 失去执行权限！"
        echo "🔧 尝试修复..."
        chmod +x "$0" 2>/dev/null || {
            echo "❌ 无法修复hook权限，提交被阻止"
            exit 1
        }
        echo "✅ hook权限已修复"
    fi

    # 检查其他关键 hooks
    local critical_hooks=("pre-commit" "pre-push")
    for hook in "${critical_hooks[@]}"; do
        local hook_path="$HOOKS_DIR/$hook"
        if [ -f "$hook_path" ] && [ ! -x "$hook_path" ]; then
            echo "🚨 WARNING: Hook $hook 失去执行权限"
            # 记录告警日志
            echo "$(date +'%Y-%m-%d %H:%M:%S') [ALERT] Hook $hook missing execute permission" >> "$LOG_DIR/permission_alerts.log"

            # 尝试修复
            if [ -f "$PROJECT_ROOT/scripts/fix_permissions.sh" ]; then
                echo "🔧 尝试修复所有hooks权限..."
                bash "$PROJECT_ROOT/scripts/fix_permissions.sh" --quiet
            fi
        fi
    done
}

# 执行权限自检
check_self_permission

# 添加日志探针
echo "$(date +'%F %T') [commit-msg] triggered with message: $(cat "$1" | head -1)" >> "$LOG_DIR/hooks.log"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# 项目根目录
PROJECT_ROOT="$(git rev-parse --show-toplevel)"
PHASE_FILE="$PROJECT_ROOT/.phase/current"

if [ ! -f "$commit_file" ]; then
    echo -e "${RED}❌ 提交信息文件不存在${NC}"
    exit 1
fi

message=$(head -n 1 "$commit_file")

# 获取当前分支
BRANCH=$(git rev-parse --abbrev-ref HEAD)

# ═══════════════════════════════════════
# 工作流Phase检查（最高优先级 - 强制执行）
# ═══════════════════════════════════════
echo -e "${CYAN}[WORKFLOW VALIDATION]${NC}"

# 检查Phase文件（强制要求）
if [[ ! -f "$PHASE_FILE" ]]; then
    echo -e "${RED}❌ ERROR: 无工作流Phase文件，拒绝提交${NC}"
    echo -e "${RED}必须先初始化工作流：${NC}"
    echo "  1. 创建.phase目录: mkdir -p .phase"
    echo "  2. 设置当前Phase: echo 'P3' > .phase/current"
    echo "  或使用工作流执行器："
    echo "  bash .workflow/executor.sh init"
    exit 1
fi

current_phase=$(cat "$PHASE_FILE")
echo -e "${GREEN}✓ 当前Phase: $current_phase${NC}"

# 自动在提交信息前添加Phase标记（如果Phase文件存在）
if [[ -f "$PHASE_FILE" ]] && ! [[ "$message" =~ ^\[P[0-7]\] ]]; then
    current_phase=$(cat "$PHASE_FILE")
    # 自动添加Phase标记
    new_message="[$current_phase] $message"
    echo "$new_message" > "$commit_file"
    echo -e "${CYAN}✓ 自动添加Phase标记: [$current_phase]${NC}"
    message="$new_message"
fi

# 分支命名规范检查（更灵活）
# 允许: feature/xxx, fix/xxx, docs/xxx, test/xxx, refactor/xxx, hotfix/xxx
if [[ "$BRANCH" =~ ^(feature|fix|docs|test|refactor|hotfix)/[a-zA-Z0-9_-]+$ ]] || \
   [[ "$BRANCH" =~ ^(feature|fix|docs|test|refactor)/PRD-[0-9]+-[a-z0-9-]+$ ]]; then
    echo -e "${GREEN}✅ 分支名称有效: $BRANCH${NC}"
elif [[ "$BRANCH" == "main" ]] || [[ "$BRANCH" == "master" ]]; then
    echo -e "${RED}❌ ERROR: 禁止直接提交到主分支！${NC}"
    echo "请创建feature分支进行开发："
    echo "  git checkout -b feature/your-task-name"
    exit 1
else
    echo -e "${YELLOW}⚠️  WARNING: 分支命名不够规范${NC}"
    echo "推荐格式: feature/task-name 或 feature/PRD-123-description"
    echo "当前分支: $BRANCH"
    # 警告但不阻止
fi

# 检查提交信息长度
if [ ${#message} -lt 10 ]; then
    echo "❌ 提交信息过短（至少10个字符）"
    echo "当前长度: ${#message}"
    exit 1
fi

# 检查提交信息格式 - 支持Phase标记
# 格式1: [P0-7][action][T-XXX] description
# 格式2: type(scope): description (传统格式)
if [[ "$message" =~ ^\[P[0-7]\]\[[a-z]+\](\[T-[0-9]+\])?\ .+ ]]; then
    # Phase格式提交
    echo "✅ Phase-based commit format detected"

    # 提取工单号（如果有）
    if [[ "$message" =~ \[T-([0-9]+)\] ]]; then
        TICKET="T-${BASH_REMATCH[1]}"
        # 验证工单是否存在
        if [ ! -f ".tickets/${TICKET}.todo" ] && [ ! -f ".tickets/${TICKET}.done" ]; then
            echo "❌ ERROR: Ticket ${TICKET} not found in .tickets/"
            echo "Please create ticket first or check ticket number"
            exit 1
        fi
        echo "✅ Ticket ${TICKET} verified"
    fi
elif [[ "$message" =~ ^(feat|fix|docs|style|refactor|perf|test|chore|build|ci)(\(.+\))?: ]]; then
    echo -e "${GREEN}✅ 传统提交格式检测通过${NC}"
    echo "提交信息: $message"
else
    echo -e "${YELLOW}⚠️  提交信息格式建议${NC}"
    echo "推荐使用以下格式之一："
    echo "  1. type: description (如: feat: add login)"
    echo "  2. type(scope): description (如: fix(auth): resolve token issue)"
    echo ""
    echo "当前提交信息: $message"
    # 不强制，继续执行
fi

# 检查当前Phase与提交的一致性
if [ -f ".phase/current" ]; then
    CURRENT_PHASE=$(cat .phase/current)
    if [[ "$message" =~ ^\[P([0-7])\] ]]; then
        MSG_PHASE="P${BASH_REMATCH[1]}"
        if [ "$MSG_PHASE" != "$CURRENT_PHASE" ]; then
            echo "⚠️  Warning: Commit phase [$MSG_PHASE] doesn't match current phase [$CURRENT_PHASE]"
        fi
    fi
fi

echo "✅ 提交信息检查通过"
exit 0
