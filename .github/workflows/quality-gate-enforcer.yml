name: Quality Gate Enforcer (Required)

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']
    types: [opened, synchronize, reopened]

# This workflow is REQUIRED and must pass before merge
# It enforces quality standards across all changes

jobs:
  quality-gate:
    name: Quality Gate Enforcement
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for proper diff

      - name: üîß Setup Environment
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck bc jq file

      - name: üêç Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: üì¶ Install Python Tools
        run: |
          pip install --upgrade pip
          pip install pylint pytest pytest-cov pyyaml radon bandit
          echo "‚úÖ Python tools installed"

      - name: üì¶ Install Node Dependencies
        run: |
          npm ci --prefer-offline --no-audit
          echo "‚úÖ Node dependencies installed"

      - name: ü™ù Verify Hook Infrastructure
        run: |
          echo "ü™ù Verifying hook infrastructure..."

          # In CI, we verify the hook SOURCE files and installer exist
          # The .git/hooks/ directory is for local development only

          # Check installer script exists
          if [ ! -f ".claude/scripts/install_ironclad_hooks.sh" ]; then
            echo "‚ùå Hook installer script missing"
            exit 1
          fi

          if [ ! -x ".claude/scripts/install_ironclad_hooks.sh" ]; then
            echo "‚ùå Hook installer not executable"
            exit 1
          fi

          echo "‚úì Hook installer: OK"

          # Verify hook source files exist and are readable
          hooks=("pre-commit" "pre-push" "commit-msg")
          for hook in "${hooks[@]}"; do
            if [ -f ".git/hooks/$hook" ] && [ -r ".git/hooks/$hook" ]; then
              echo "‚úì $hook source: OK"
            else
              echo "‚ÑπÔ∏è  $hook: not in .git/hooks (expected in CI)"
            fi
          done

          echo "‚úì Hook infrastructure verified"
          echo "Note: Hooks are installed locally by developers, not in CI"

      - name: üîç Run Shellcheck (Incremental)
        run: |
          echo "üîç Running shellcheck on CHANGED shell scripts only..."

          # Get list of changed .sh files in this PR/commit
          changed_scripts=$(git diff --name-only --diff-filter=ACM origin/main...HEAD | grep "\.sh$" || true)

          if [ -z "$changed_scripts" ]; then
            echo "‚ÑπÔ∏è  No shell scripts changed in this PR"
            echo "‚úÖ Shellcheck check skipped (no changes)"
            exit 0
          fi

          echo "üìù Changed scripts:"
          echo "$changed_scripts"
          echo ""

          error_count=0

          # Only check changed scripts
          # Exclude SC2034 (unused variable), SC2155 (declare and assign), SC2164 (cd without error check) as non-critical
          while IFS= read -r script; do
            if [ -f "$script" ]; then
              echo "Checking: $script"
              if ! shellcheck -S warning -e SC2034 -e SC2155 -e SC2164 "$script"; then
                echo "‚ùå Shellcheck failed for $script"
                ((error_count++))
              else
                echo "‚úÖ $script passed"
              fi
            fi
          done <<< "$changed_scripts"

          if [ $error_count -eq 0 ]; then
            echo ""
            echo "‚úÖ All changed shell scripts passed shellcheck"
            echo "‚ÑπÔ∏è  Note: Only checking files modified in this PR (incremental approach)"
          else
            echo "::error::Shellcheck found issues in $error_count changed files"
            echo "::error::Fix these issues in the files YOU modified"
            exit 1
          fi

      - name: üêç Python Syntax & Import Check
        run: |
          echo "üêç Checking Python syntax and imports..."

          # Find Python files in important directories
          py_files=$(find ./src ./backend ./.claude -name "*.py" 2>/dev/null || echo "")

          if [ -z "$py_files" ]; then
            echo "‚ÑπÔ∏è No Python files found in src/backend/.claude, skipping"
            exit 0
          fi

          error_count=0
          for file in $py_files; do
            echo "Checking: $file"

            # Method 1: Syntax check (fast, no false positives)
            if ! python3 -m py_compile "$file" 2>/dev/null; then
              echo "‚ùå Syntax error in $file"
              python3 -m py_compile "$file"  # Show actual error
              ((error_count++))
              continue
            fi

            # Method 2: Import check (catch undefined names)
            if ! python3 -c "import ast; ast.parse(open('$file').read())" 2>/dev/null; then
              echo "‚ö†Ô∏è AST parse issue in $file (may be OK)"
            fi
          done

          if [ $error_count -eq 0 ]; then
            echo "‚úÖ All Python files have valid syntax"
          else
            echo "::error::Found syntax errors in $error_count files"
            exit 1
          fi

      - name: üü¢ JavaScript Syntax Check
        run: |
          echo "üü¢ Checking JavaScript syntax..."

          # Simple syntax check with Node.js
          # Skip JSX files (React components) - they're checked by build process
          js_files=$(find . -name "*.js" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./frontend/*" -type f)

          if [ -z "$js_files" ]; then
            echo "‚ÑπÔ∏è No non-JSX JavaScript files found"
            echo "‚ÑπÔ∏è JSX/React files are checked by build process"
            exit 0
          fi

          error_count=0
          for file in $js_files; do
            # Skip if file contains JSX syntax
            if grep -q "<.*>" "$file" 2>/dev/null; then
              echo "‚ÑπÔ∏è Skipping JSX file: $file"
              continue
            fi

            if ! node --check "$file" 2>/dev/null; then
              echo "‚ùå Syntax error: $file"
              node --check "$file"  # Show error
              ((error_count++))
            fi
          done

          if [ $error_count -eq 0 ]; then
            echo "‚úÖ All non-JSX JavaScript files have valid syntax"
          else
            echo "::error::Found syntax errors in $error_count files"
            exit 1
          fi

      - name: üß™ Run Test Suite
        run: |
          echo "üß™ Running test suite..."
          npm run test:ci
          echo "‚úÖ Tests passed"

      - name: üìä Check Test Coverage
        run: |
          echo "üìä Verifying test coverage threshold..."

          if [ -f "coverage/coverage-summary.json" ]; then
            coverage=$(node -e "const c=require('./coverage/coverage-summary.json'); console.log(c.total.lines.pct)")
            echo "Current coverage: $coverage%"

            threshold=80
            if (( $(echo "$coverage < $threshold" | bc -l) )); then
              echo "::error::Coverage insufficient: $coverage% < $threshold%"
              exit 1
            else
              echo "‚úÖ Coverage meets threshold: $coverage% ‚â• $threshold%"
            fi
          else
            echo "::warning::Coverage summary not found"
          fi

      - name: üîê Security Scan - Secrets Detection
        run: |
          echo "üîê Scanning for secrets in changed files..."

          # Get changed files
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            base_sha="${{ github.event.pull_request.base.sha }}"
            head_sha="${{ github.event.pull_request.head.sha }}"
          else
            # For push events
            if [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              base_sha="${{ github.event.before }}"
              head_sha="${{ github.sha }}"
            else
              # First commit, check against empty tree
              base_sha="4b825dc642cb6eb9a060e54bf8d69288fbee4904"
              head_sha="${{ github.sha }}"
            fi
          fi

          # Patterns to detect
          patterns=(
            "AKIA[0-9A-Z]{16}"                           # AWS Access Key
            "sk-[a-zA-Z0-9]{48}"                        # OpenAI API Key
            "ghp_[a-zA-Z0-9]{36}"                       # GitHub Personal Access Token
            "password\s*[:=]\s*['\"][^'\"]{8,}"        # Password assignments
            "secret\s*[:=]\s*['\"][^'\"]{8,}"          # Secret assignments
            "token\s*[:=]\s*['\"][^'\"]{32,}"          # Token assignments
            "api[_-]?key\s*[:=]\s*['\"][^'\"]{16,}"    # API Key assignments
          )

          echo "Checking diff: $base_sha..$head_sha"
          diff_content=$(git diff "$base_sha..$head_sha" || echo "")

          found=0
          for pattern in "${patterns[@]}"; do
            if echo "$diff_content" | grep -E "$pattern" >/dev/null 2>&1; then
              echo "::error::Potential secret detected matching pattern: $pattern"
              ((found++))
            fi
          done

          if [ $found -gt 0 ]; then
            echo "::error::Found $found potential secrets in changed files"
            exit 1
          else
            echo "‚úÖ No secrets detected in changes"
          fi

      - name: üîê Security Scan - Bandit (Python)
        run: |
          echo "üîê Running Bandit security scan on Python files..."

          py_files=$(find . -name "*.py" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./venv/*" -type f)

          if [ -z "$py_files" ]; then
            echo "‚ÑπÔ∏è No Python files found, skipping"
            exit 0
          fi

          if bandit -r . -ll -x "./node_modules/*,./.git/*,./venv/*" --format txt; then
            echo "‚úÖ Bandit security scan passed"
          else
            echo "::warning::Bandit found potential security issues (review recommended)"
          fi

      - name: üìã Document Count Check
        run: |
          echo "üìã Checking root document count..."

          count=$(find . -maxdepth 1 -name "*.md" -not -name "PLAN.md" | wc -l)
          echo "Root document count: $count"

          max_allowed=7
          if [ $count -gt $max_allowed ]; then
            echo "::warning::Too many root documents: $count > $max_allowed"
            echo "Consider moving some to docs/ or archive/"
          else
            echo "‚úÖ Document count acceptable: $count ‚â§ $max_allowed"
          fi

      - name: üìù Validate Key Files Exist
        run: |
          echo "üìù Checking for required files..."

          required_files=(
            "README.md"
            "CLAUDE.md"
            "VERSION"
            ".claude/config.yml"
            ".workflow/gates.yml"
            ".workflow/manifest.yml"
            "package.json"
          )

          missing=0
          for file in "${required_files[@]}"; do
            if [ -f "$file" ]; then
              echo "‚úÖ $file exists"
            else
              echo "‚ùå $file missing"
              ((missing++))
            fi
          done

          if [ $missing -gt 0 ]; then
            echo "::error::$missing required files are missing"
            exit 1
          fi

          echo "‚úÖ All required files present"

      - name: üî¢ Version Consistency Check
        run: |
          echo "üî¢ Checking version consistency..."

          version=$(cat VERSION)
          echo "VERSION file: $version"

          settings_ver=$(python3 -c "import json; print(json.load(open('.claude/settings.json'))['version'])" 2>/dev/null || echo "unknown")
          echo "settings.json: $settings_ver"

          manifest_ver=$(python3 -c "import yaml; print(yaml.safe_load(open('.workflow/manifest.yml'))['version'])" 2>/dev/null || echo "unknown")
          echo "manifest.yml: $manifest_ver"

          package_ver=$(node -e "console.log(require('./package.json').version)" 2>/dev/null || echo "unknown")
          echo "package.json: $package_ver"

          # Check consistency
          inconsistent=0
          if [ "$version" != "$settings_ver" ]; then
            echo "::error::VERSION != settings.json"
            ((inconsistent++))
          fi
          if [ "$version" != "$manifest_ver" ]; then
            echo "::error::VERSION != manifest.yml"
            ((inconsistent++))
          fi
          if [ "$version" != "$package_ver" ]; then
            echo "::error::VERSION != package.json"
            ((inconsistent++))
          fi

          if [ $inconsistent -gt 0 ]; then
            echo "::error::Version inconsistency detected in $inconsistent files"
            exit 1
          fi

          echo "‚úÖ Version consistency verified: $version"

      - name: üö™ Block on Failure
        if: failure()
        run: |
          echo "::error::‚ùå Quality gate failed!"
          echo ""
          echo "This PR cannot be merged until all quality checks pass."
          echo "Please review the logs above and fix any issues."
          echo ""
          exit 1

  quality-summary:
    name: Quality Gate Summary
    runs-on: ubuntu-latest
    needs: quality-gate
    if: always()

    steps:
      - name: üìä Generate Summary
        run: |
          if [ "${{ needs.quality-gate.result }}" == "success" ]; then
            echo "## ‚úÖ Quality Gate: PASSED"
            echo ""
            echo "All quality checks have passed successfully!"
            echo ""
            echo "- ‚úÖ Hook integrity verified"
            echo "- ‚úÖ Code linting passed"
            echo "- ‚úÖ Tests passed"
            echo "- ‚úÖ Coverage threshold met"
            echo "- ‚úÖ Security scan clean"
            echo "- ‚úÖ Version consistency verified"
            echo ""
            echo "üéâ This PR is ready for review!"
          else
            echo "## ‚ùå Quality Gate: FAILED"
            echo ""
            echo "Some quality checks failed. Please fix the issues above."
            echo ""
            echo "Review the logs in the 'Quality Gate Enforcement' job for details."
            echo ""
            exit 1
          fi
